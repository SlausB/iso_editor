<?xml version="1.0" encoding="utf-8"?>
<s:SpriteVisualElement xmlns:fx="http://ns.adobe.com/mxml/2009" 
               xmlns:s="library://ns.adobe.com/flex/spark" 
               xmlns:mx="library://ns.adobe.com/flex/mx"
			   percentWidth="100"
			   percentHeight="100"
			   addedToStage="onInit()"
			   mouseDown="onMouseDown(event)"
			   mouseUp="onMouseUp(event)"
			   mouseMove="onMouseMove(event)"
			   mouseOut="onMouseOut(event)"
			   >
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
import blisc.core.Blisc;
import blisc.instances.BliscComplex;
import blisc.instances.BliscComplexWithinCompound;
import blisc.instances.BliscCompound;
import blisc.instances.BliscUnit;
import blisc.pathfinding.AStar;
import blisc.templates.BliscComplexTemplate;
import blisc.templates.BliscRegion;
import blisc.templates.BliscRegionWithinComplex;
import blisc.templates.BliscUnitTemplate;
import com.junkbyte.console.Cc;
import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.DisplayObject;
import flash.display.MovieClip;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.Point;
import flash.text.TextField;
import flash.ui.Keyboard;
import flash.utils.getTimer;
import list_items.CompoundTableItem;
import list_items.ListItem;
import list_items.TemplateTableItem;
import mx.core.IToolTip;
import mx.core.UIComponent;
import mx.events.DragEvent;
import mx.managers.DragManager;
import mx.managers.ToolTipManager;
import project_data.ComplexTemplate;
import project_data.ComplexWithinCompound;
import project_data.CompoundTemplate;
import project_data.Layer;
import project_data.Map;
import project_data.ObjectInstance;
import project_data.ObjectTemplate;
import project_data.Region;
import project_data.SingleResource;
import project_data.UnitProperties;
import utils.Utils;
import view.Projection;
		
		/** We can draw only on child objects - not upon SpriteVisualElement itself :( .*/
		private var _bliscViewport : Sprite = new Sprite;
		
		public var _blisc : Blisc;
		
		public var _isometryObjects : Vector.< IsometryObject > = new Vector.< IsometryObject >;
		
		/** Dirty (but only one known) way to handle viewport size changes.*/
		private var _previousWidth : Number;
		private var _previousHeight : Number;
		
		/** What is currently displayed.*/
		private var _displaying : Map = null;
		
		private var _project : Project;
		private var _main : Main;
		
		private var _gridDrawer : GridDrawer = null;
		
		public var _objectTip : IToolTip = null;
		/** Object which is currently can be edited using "Instance properties" window.*/
		public var _selected : IsometryObject = null;
		/** Object which is currently under mouse (if isometry was in selecting mode).*/
		public var _over : IsometryObject = null;
		
		/** Arrow which must point to object adding position.*/
		[ Embed( source = "../arrow-down-blue.png" ) ]
		private var _pointerClass : Class;
		private static const POINTER_X : Number = 18;
		private static const POINTER_Y : Number = 35;
		private var _pointer : DisplayObject;
		
		/** Which object was dragged in last to position it again using "alt" key.*/
		public var _lastPositioned : ObjectTemplate = null;
		
		/** How much pixels at the edge of isometric screen are sensitive for scrolling.*/
		private static const SCROLL_FRAME : Number = 100;
		/** How much pixels scroll per second.*/
		private static const SCROLL_SPEED : Number = 400;
		
		private var _regionsCache : Vector.< BliscRegion > = new Vector.< BliscRegion >;
		
		
		
		public function HideTip() : void
		{
			if ( _objectTip != null )
			{
				ToolTipManager.destroyToolTip( _objectTip );
				_objectTip = null;
			}
		}
		public function ShowTip( tip:IToolTip ) : void
		{
			HideTip();
			_objectTip = tip;
		}
		
		private function onInit( ... args ) : void
		{
			addChild( _bliscViewport );
			
			_previousWidth = width;
			_previousHeight = height;
			
			_pointer = ( new _pointerClass ) as DisplayObject;
			_pointer.visible = false;
			addChild( _pointer );
			
			stage.addEventListener( Event.ENTER_FRAME, onEnterFrame );
		}
		
		public function Init( project:Project, main:Main ): void
		{
			_project = project;
			_main = main;
		}
		
		private var _previousTime:int = 0;
		private function onEnterFrame( ... args ): void
		{
			if ( width != _previousWidth || height != _previousHeight )
			{
				_previousWidth = width;
				_previousHeight = height;
				
				if ( _blisc != null )
				{
					_blisc.SetCameraSize( width, height );
				}
				
				if ( _gridDrawer != null )
				{
					_gridDrawer.SetViewport( width, height );
				}
			}
			
			if ( _blisc != null )
			{
				var currentTime:int = getTimer();
				var elapsedSeconds:Number = ( currentTime - _previousTime ) / 1000.0;
				_previousTime = currentTime;
				if ( elapsedSeconds > 0.1 )
				{
					elapsedSeconds = 0.1;
				}
				
				
				//scroll isometric view using sensitive mouse:
				if ( _main._ctrlDown || DragManager.isDragging )
				{
					var horisontalScrolling:Number = 0;
					var verticalScrolling:Number = 0;
					const scrollStep:Number = SCROLL_SPEED * elapsedSeconds;
					
					//scroll right:
					if ( mouseX >= ( width - SCROLL_FRAME ) && mouseX <= width )
					{
						horisontalScrolling = scrollStep;
					}
					//scroll left:
					else if ( mouseX >= 0 && mouseX <= SCROLL_FRAME )
					{
						horisontalScrolling = -scrollStep;
					}
					
					//scroll up:
					if ( mouseY >= 0 && mouseY <= SCROLL_FRAME )
					{
						verticalScrolling = -scrollStep;
					}
					else if ( mouseY >= ( height - SCROLL_FRAME ) && mouseY <= height )
					{
						verticalScrolling = scrollStep;
					}
					
					_blisc.MoveCamera( horisontalScrolling, verticalScrolling );
				}
				
				
				for each ( var isometryObject:IsometryObject in _isometryObjects )
				{
					isometryObject.Update( elapsedSeconds );
				}
				
				
				_blisc.draw();
			}
		}
		
		public function onIsometryMouseEvent( type:int, opaqueData:* ): void
		{
			var isometryObject:IsometryObject = opaqueData as IsometryObject;
			if ( isometryObject != null )
			{
				isometryObject.OnMouseEvent( type );
			}
		}
		
		
		private function AddUnit( unitDesc:UnitDesc, tileX : Number, tileY : Number ): void
		{
			var foundLayer:String = null;
			for each ( var layer:Layer in _project._data._layers )
			{
				if ( layer._units )
				{
					foundLayer = layer._name;
				}
			}
			
			if ( foundLayer == null )
			{
				_main.PopUp( "Specify \"units\" field for at least one layer.", Main.POP_UP_ERROR );
				return;
			}
			
			
			var unit:Unit = new Unit( _main, unitDesc );
			_isometryObjects.push( unit );
			
			//initing surfaces:
			unitDesc._template._surfaces.length = 0;
			var unitProperties : UnitProperties = _project.FindUnitProperties( unitDesc, true );
			for each ( var surface : Region in unitProperties._surfaces )
			{
				unitDesc._template._surfaces.push( ObtainBliscRegion( surface, _regionsCache ) );
			}
			
			var bliscUnit : BliscUnit = new BliscUnit( unitDesc._template, unit, _blisc, foundLayer );
			unit.Init( bliscUnit, tileX, tileY );
			_blisc.AddObject( bliscUnit );
		}
		
		public static function ObtainBliscRegion( region : Region, cache : Vector.< BliscRegion > ) : BliscRegion
		{
			for each ( var bliscRegion : BliscRegion in cache )
			{
				if ( bliscRegion._name == region._name && bliscRegion._color == region._color && bliscRegion._type == region._type )
				{
					return bliscRegion;
				}
			}
			
			var newBliscRegion : BliscRegion = new BliscRegion( region._name, region._type, region._color );
			cache.push( newBliscRegion );
			return newBliscRegion;
		}
		
		private function AddObject( objectInstance:ObjectInstance ): void
		{
			var isometryObject:IsometryObject = new IsometryObject( objectInstance, _main );
			_isometryObjects.push( isometryObject );
			
			var bliscCompound : BliscCompound = IE_Utils.CreateBliscCompound( _regionsCache, isometryObject, _blisc, objectInstance._template, _project );
			
			isometryObject._view = bliscCompound;
			
			bliscCompound.SetTileX( objectInstance._tileCoords.x );
			bliscCompound.SetTileY( objectInstance._tileCoords.y );
			_blisc.AddObject( bliscCompound );
		}
		
		private static const GRID_DRAWER_LAYER_NAME:String = "grid_drawer_holder";
		
		/** Unload currently displaying map and display it again.*/
		public function Reinit(): void
		{
			if ( displaying != null )
			{
				const cameraFocusX:Number = _blisc.cameraFocusX;
				const cameraFocusY:Number = _blisc.cameraFocusY;
				
				
				var units:Vector.< UnitDesc > = new Vector.< UnitDesc >;
				for each ( var potentialUnit:IsometryObject in _isometryObjects )
				{
					var unit:Unit = potentialUnit as Unit;
					if ( unit == null )
					{
						continue;
					}
					
					units.push( unit.unitDesc );
				}
				
				Display( displaying );
				
				_blisc.MoveCameraTo( cameraFocusX, cameraFocusY );
				
				for each ( var unitDesc:UnitDesc in units )
				{
					AddUnit( unitDesc, 0, 0 );
				}
			}
		}
		
		/** Display specified map. Abandon any other maps if there are.*/
		public function Display( map:Map ): void
		{
			Unload();
			
			_main._scale_1.selected = true;
			
			_displaying = map;
			
			_main._mapPropertiesArea.enabled = true;
			_main._isoTileX.text = _main._isoTileY.text = "N/A";
			_main._drawBorder.selected = _displaying._drawBorder;
			_main._drawGrid.selected = _displaying._drawGrid;
			_main._clampToTile.selected = _displaying._clampToTiles;
			_main._unitsSpeed.text = _displaying._unitsSpeed.toString();
			
			var aStar : AStar = new AStar( map._right, map._down, _project._data._tileSize, _project.side );
			_blisc = new Blisc( _bliscViewport, onIsometryMouseEvent, width, height, map._right + 100, map._down + 100, 5, _project.side, aStar );
			
			//adding an ability to draw map's grid:
			_blisc.AddLayer( GRID_DRAWER_LAYER_NAME );
			var drawerComplexTemplate : BliscComplexTemplate = new BliscComplexTemplate(
				"grid_drawer",
				null,
				new Point,
				new Point,
				GRID_DRAWER_LAYER_NAME,
				new Vector.< BliscRegionWithinComplex >
			);
			var drawerCompound:BliscCompound = new BliscCompound( null, _blisc, drawerComplexTemplate );
			_gridDrawer = new GridDrawer( map, width, height, _project );
			_gridDrawer._layerId = GRID_DRAWER_LAYER_NAME;
			drawerCompound._complexes[ 0 ]._complex = new BliscComplex( drawerComplexTemplate, _gridDrawer );
			
			for each ( var layer : Layer in _project._data._layers )
			{
				_blisc.AddLayer( layer._name, layer._visible );
				
				if ( layer._gridHolder )
				{
					_gridDrawer._layerId = layer._name;
				}
			}
			
			_blisc.AddObject( drawerCompound );
			
			for each ( var objectInstance : ObjectInstance in map._instances )
			{
				AddObject( objectInstance );
			}
		}
		
		/** Remove currently displaying map (if there is such) and abandon it.*/
		public function Unload() : void
		{
			_main._mapPropertiesArea.enabled = false;
			_main._isoTileX.text = _main._isoTileY.text = "N/A";
			_main._unitsSpeed.text = "N/A";
			
			_selected = null;
			_main.ShowObjectProperties();
			
			_over = null;
			
			if ( _displaying == null )
			{
				return;
			}
			
			if ( _blisc != null )
			{
				for each ( var isometryObject:IsometryObject in _isometryObjects )
				{
					isometryObject.Destroy();
				}
				_isometryObjects.length = 0;
				
				_blisc.Destroy();
				_blisc = null;
			}
			
			_displaying = null;
			
			_dragging = null;
			_isDragging = null;
			
			_regionsCache.length = 0;
		}
		
		public function onDragEnter( event:DragEvent ): void
		{
			if ( _blisc != null )
			{
				if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) ||
					event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) ||
					event.dragSource.hasFormat( Global.DRAG_FORMAG_UNIT_DESC ) )
				{
					DragManager.acceptDragDrop( event.currentTarget as UIComponent );
				}
			}
		}
		
		/** Returns isometric coordinates of the mouse within Blisc view.*/
		private function ResolveMouseIso( clampToTiles:Boolean = false, tilePosToFill:Point = null ): Point
		{
			var result:Point = new Point;
			if ( _blisc != null )
			{
				_blisc.ScreenToIso( _bliscViewport.mouseX, _bliscViewport.mouseY, result );
				
				var tileX:Number = result.x / _project.side;
				var tileY:Number = result.y / _project.side;
				
				if ( clampToTiles )
				{
					tileX = Math.floor( tileX );
					tileY = Math.floor( tileY );
				}
				
				result.x = tileX * _project.side;
				result.y = tileY * _project.side;
				
				if ( tilePosToFill != null )
				{
					tilePosToFill.setTo( tileX, tileY );
				}
			}
			return result;
		}
		
		public function ShowPointerOverMouse( clampToTiles:Boolean ): void
		{
			_pointer.visible = true;
			var mouse:Point = ResolveMouseIso( clampToTiles );
			var flatMouse:Point = _blisc.IsoToDisplay( mouse.x, mouse.y, new Point );
			_pointer.x = flatMouse.x - POINTER_X;
			_pointer.y = flatMouse.y - POINTER_Y;
		}
		
		public function onDragOver( event:DragEvent ): void
		{
			if ( _blisc != null )
			{
				if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) || 
					event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) ||
					event.dragSource.hasFormat( Global.DRAG_FORMAG_UNIT_DESC ) )
				{
					ShowPointerOverMouse( displaying._clampToTiles );
					
					DragManager.showFeedback( DragManager.COPY );
					return;
				}
			}
			
			DragManager.showFeedback( DragManager.NONE );
		}
		
		public function onDragDrop( event:DragEvent ): void
		{
			if ( _displaying == null || _blisc == null )
			{
				_main.PopUp( "Select some map first.", Main.POP_UP_ERROR );
				return;
			}
			
			_pointer.visible = false;
			var tileMousePos:Point = new Point;
			var mouse:Point = ResolveMouseIso( displaying._clampToTiles, tileMousePos );
			
			if ( event.dragSource.hasFormat( Global.DRAG_FORMAG_UNIT_DESC ) )
			{
				AddUnit( event.dragSource.dataForFormat( Global.DRAG_FORMAG_UNIT_DESC ) as UnitDesc, tileMousePos.x, tileMousePos.y );
				return;
			}
			
			var addingTemplate:ObjectTemplate = null;
			
			if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) )
			{
				addingTemplate = event.dragSource.dataForFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) as ObjectTemplate;
			}
			else if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) )
			{
				addingTemplate = event.dragSource.dataForFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) as ObjectTemplate;
			}
			
			if ( addingTemplate != null )
			{
				_lastPositioned = addingTemplate;
				
				AddTemplate( addingTemplate, tileMousePos.x, tileMousePos.y );
				
				if ( addingTemplate is ComplexTemplate )
				{
					var templateTableItem:TemplateTableItem = ListItem.FindListItem( addingTemplate, _main._templates_table.dataProvider ) as TemplateTableItem;
					if ( templateTableItem == null )
					{
						Cc.error( "E: Isometry.onDragDrop(): TemplateTableItem was NOT found." );
					}
					else
					{
						templateTableItem.UpdateUsage( _main );
						_main._templates_table.dataProvider.itemUpdated( templateTableItem );
					}
				}
				else if ( addingTemplate is CompoundTemplate )
				{
					var compoundTableItem:CompoundTableItem = ListItem.FindListItem( addingTemplate, _main._compounds_table.dataProvider ) as CompoundTableItem;
					if ( compoundTableItem == null )
					{
						Cc.error( "E: Isometry.onDragDrop(): CompoundTableItem was NOT found." );
					}
					else
					{
						compoundTableItem.UpdateUsage( _main );
						_main._compounds_table.dataProvider.itemUpdated( compoundTableItem );
					}
				}
			}
		}
		
		public function AddTemplate( template:ObjectTemplate, x:Number, y:Number ): void
		{
			var addingInstance:ObjectInstance = new ObjectInstance;
			addingInstance.Init( template );
			addingInstance._tileCoords.x = x;
			addingInstance._tileCoords.y = y;
			
			_displaying._instances.push( addingInstance );
			
			AddObject( addingInstance );
		}
		
		public function get displaying(): project_data.Map
		{
			return _displaying;
		}
		
		
		/** Object which was captured to drag.*/
		private var _dragging:IsometryObject = null;
		/** Did any mouse movement happened after mouse was pushed down.*/
		private var _wasDrag:Boolean = false;
		/** Mouse position (in local coordinates) relatively to dragging object when it was pushed down to start dragging or null if nothing is currently being dragged.*/
		private var _isDragging:Point = null;
		private function GetObj( e:MouseEvent, local:Point = null ): IsometryObject
		{
			if ( _blisc == null )
			{
				return null;
			}
			
			if ( local == null )
			{
				local = globalToLocal( new Point( e.stageX, e.stageY ) );
			}
			return _blisc.GetOpaqueDataAt( local.x, local.y ) as IsometryObject;
		}
		private function onMouseDown( e:MouseEvent ): void
		{
			_wasDrag = false;
			
			if ( _blisc == null )
			{
				return;
			}
			
			var local:Point = globalToLocal( new Point( e.stageX, e.stageY ) );
			
			if ( _main._qDown )
			{
				if ( _lastPositioned != null )
				{
					var tilePos:Point = new Point;
					ResolveMouseIso( displaying._clampToTiles, tilePos );
					AddTemplate( _lastPositioned, tilePos.x, tilePos.y );
				}
			}
			else if ( _main._ctrlDown )
			{
				var newDragging:IsometryObject = GetObj( e, local );
				if ( newDragging != null )
				{
					_isDragging = new Point( local.x - newDragging._view.GetX(), local.y - newDragging._view.GetY() );
					_dragging = newDragging;
					
					if ( _selected != null )
					{
						_selected.Deselect();
					}
					newDragging.Select();
					_main.ShowObjectProperties();
					_main._isometry.HideTip();
				}
			}
			else
			{
				_blisc.OnMouseDown( local.x, local.y );
			}
		}
		private function onMouseUp( e:MouseEvent ): void
		{
			if ( _blisc == null )
			{
				return;
			}
			
			_isDragging = null;
			
			var local:Point = globalToLocal( new Point( e.stageX, e.stageY ) );
			
			if ( _main._ctrlDown )
			{
			}
			else
			{
				if ( _wasDrag == false )
				{
					//send currently selected unit to specified position:
					if ( _selected is Unit )
					{
						var sendingUnitPos:Point = ResolveMouseIso();
						( _selected as Unit ).MoveTo( sendingUnitPos.x, sendingUnitPos.y, _main._strictMove.selected );
					}
				}
				
				_blisc.OnMouseUp( local.x, local.y );
			}
		}
		private function onMouseMove( e:MouseEvent ): void
		{
			_wasDrag = true;
			
			if ( _blisc == null )
			{
				return;
			}
			
			var local:Point = globalToLocal( new Point( e.stageX, e.stageY ) );
			
			if ( DragManager.isDragging == false )
			{
				if ( _main._qDown )
				{
					ShowPointerOverMouse( displaying._clampToTiles );
					return;
				}
				//try sending currently selected unit to hovering position:
				else if ( _selected is Unit )
				{
					ShowPointerOverMouse( false );
				}
				else
				{
					_pointer.visible = false;
				}
			}
			
			//displaying hovering tile coordinates:
			var iso:Point = new Point;
			_blisc.ScreenToIso( local.x, local.y, iso );
			_main._isoTileX.text = Math.floor( iso.x / _project.side ).toString();
			_main._isoTileY.text = Math.floor( iso.y / _project.side ).toString();
			
			if ( _main._ctrlDown && _isDragging != null )
			{
				var newIsoPos:Point = Utils.ToIso( local.x - _isDragging.x, local.y - _isDragging.y, new Point );
				var newTilePos:Point = new Point( newIsoPos.x / _project.side, newIsoPos.y / _project.side );
				if ( displaying._clampToTiles )
				{
					newTilePos.x = Math.round( newTilePos.x );
					newTilePos.y = Math.round( newTilePos.y );
				}
				_dragging._view.SetTileX( newTilePos.x );
				_dragging._view.SetTileY( newTilePos.y );
				_dragging._objectInstance._tileCoords.x = newTilePos.x;
				_dragging._objectInstance._tileCoords.y = newTilePos.y;
				_main.ShowObjectProperties();
			}
			else
			{
				_blisc.OnMouseMove( local.x, local.y );
				
				UpdateHoverTip( local );
			}
		}
		private function onMouseOut( ... args ): void
		{
			HideTip();
		}
		
		private function UpdateHoverTip( local:Point ): void
		{
			var tipText:String = "";
			const globalX:Number = local.x + _blisc.cameraOffsetX;
			const globalY:Number = local.y + _blisc.cameraOffsetY;
			
			if ( _main._tipGraphics.selected )
			{
				var objects:Vector.< * > = _blisc.ObjectsUnderPoint( globalX, globalY );
				for ( var i:int = 0; i < objects.length; ++i )
				{
					var io:IsometryObject = objects[ i ] as IsometryObject;
					if ( io == null )
					{
						continue;
					}
					//units doesn't have that property:
					if ( io._objectInstance == null )
					{
						continue;
					}
					
					if ( tipText.length > 0 )
					{
						tipText = tipText + "\n";
					}
					tipText = tipText + io._objectInstance._template._name;
				}
			}
			else
			{
				var iso : Point = Utils.ToIso( globalX, globalY, new Point );
				
				for each ( var isometryObject : IsometryObject in _isometryObjects )
				{
					//unit:
					var bliscCompound : BliscCompound = isometryObject._view as BliscCompound;
					if ( bliscCompound == null )
					{
						continue;
					}
					
					var intersects : Boolean = false;
					
					for each ( var bcwc : BliscComplexWithinCompound in bliscCompound._complexes )
					{
						const x : Number = bcwc._complex._bdo.GetIsoX();
						const y : Number = bcwc._complex._bdo.GetIsoY();
						
						for each ( var region:BliscRegionWithinComplex in bcwc._complex._template._regions )
						{
							//we need only space:
							if ( region._region._type != BliscRegion.TYPE_SPACE )
							{
								continue;
							}
							
							for each ( var tile : Point in region._tiles )
							{
								//left:
								if ( iso.x >= ( x + tile.x * _project.side ) )
								{
									//right:
									if ( iso.x <= ( x + tile.x * _project.side + _project.side ) )
									{
										//up:
										if ( iso.y >= ( y + tile.y * _project.side ) )
										{
											//down:
											if ( iso.y <= ( y + tile.y * _project.side + _project.side ) )
											{
												intersects = true;
												break;
											}
										}
									}
								}
							}
							
							if ( intersects )
							{
								break;
							}
						}
						
						if ( intersects )
						{
							break;
						}
					}
					
					if ( intersects )
					{
						if ( tipText.length > 0 )
						{
							tipText = tipText + "\n";
						}
						tipText = tipText + bliscCompound._template._name;
					}
				}
			}
			
			if ( tipText.length > 0 )
			{
				ShowTip( ToolTipManager.createToolTip( tipText, _main.stage.mouseX - 2, _main.stage.mouseY + 20 ) );
			}
			else
			{
				HideTip();
			}
		}
		
		]]>
	</fx:Script>
	
	
</s:SpriteVisualElement>