<?xml version="1.0" encoding="utf-8"?>
<s:SpriteVisualElement xmlns:fx="http://ns.adobe.com/mxml/2009" 
               xmlns:s="library://ns.adobe.com/flex/spark" 
               xmlns:mx="library://ns.adobe.com/flex/mx"
			   percentWidth="100"
			   percentHeight="100"
			   addedToStage="onInit()"
			   mouseDown="onMouseDown(event)"
			   mouseUp="onMouseUp(event)"
			   mouseMove="onMouseMove(event)"
			   >
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
import blisc.Blisc;
import blisc.BliscAnimation;
import blisc.BliscComplex;
import blisc.BliscComplexTemplate;
import blisc.BliscComplexWithinCompound;
import blisc.BliscComplexWithinCompoundTemplate;
import blisc.BliscCompound;
import blisc.BliscCompoundTemplate;
import blisc.BliscDisplayObject;
import blisc.BliscObjectTemplate;
import blisc.BliscSprite;
import blisc.BliscUnit;
import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.DisplayObject;
import flash.display.MovieClip;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.Point;
import flash.text.TextField;
import flash.ui.Keyboard;
import flash.utils.getTimer;
import mx.core.IToolTip;
import mx.core.UIComponent;
import mx.events.DragEvent;
import mx.managers.DragManager;
import mx.managers.ToolTipManager;
import project_data.ComplexTemplate;
import project_data.ComplexWithinCompound;
import project_data.CompoundTemplate;
import project_data.Layer;
import project_data.Map;
import project_data.ObjectInstance;
import project_data.ObjectTemplate;
import project_data.SingleResource;
import utils.Utils;
import view.Projection;
		
		/** We can draw only on child objects - not upon SpriteVisualElement itself :( .*/
		private var _bliscViewport:Sprite = new Sprite;
		
		public var _blisc:Blisc;
		
		private var _isometryObjects:Vector.< IsometryObject > = new Vector.< IsometryObject >;
		
		/** Dirty (but only one known) way to handle viewport size changes.*/
		private var _previousWidth:Number;
		private var _previousHeight:Number;
		
		/** What is currently displayed.*/
		private var _displaying:Map = null;
		
		private var _project:Project;
		private var _main:Main;
		
		private var _gridDrawer:GridDrawer = null;
		
		public var _objectTip:IToolTip = null;
		/** Object which is currently can be edited using "Instance properties" window.*/
		public var _selected:IsometryObject = null;
		/** Object which is currently under mouse (if isometry was in selecting mode).*/
		public var _over:IsometryObject = null;
		
		
		public function HideTip(): void
		{
			if ( _objectTip != null )
			{
				ToolTipManager.destroyToolTip( _objectTip );
				_objectTip = null;
			}
		}
		
		private function onInit( ... args ): void
		{
			addChild( _bliscViewport );
			
			_previousWidth = width;
			_previousHeight = height;
			
			stage.addEventListener( Event.ENTER_FRAME, onEnterFrame );
		}
		
		public function Init( project:Project, main:Main ): void
		{
			_project = project;
			_main = main;
		}
		
		private var _previousTime:int = 0;
		private function onEnterFrame( ... args ): void
		{
			if ( width != _previousWidth || height != _previousHeight )
			{
				_previousWidth = width;
				_previousHeight = height;
				
				if ( _blisc != null )
				{
					_blisc.SetCameraSize( width, height );
				}
				
				if ( _gridDrawer != null )
				{
					_gridDrawer.SetViewport( width, height );
				}
			}
			
			if ( _blisc != null )
			{
				var currentTime:int = getTimer();
				var elapsedSeconds:Number = ( currentTime - _previousTime ) / 1000.0;
				_previousTime = currentTime;
				if ( elapsedSeconds > 0.1 )
				{
					elapsedSeconds = 0.1;
				}
				
				for each ( var isometryObject:IsometryObject in _isometryObjects )
				{
					isometryObject.Update( elapsedSeconds );
				}
				
				_blisc.draw();
			}
		}
		
		public function onIsometryMouseEvent( type:int, opaqueData:* ): void
		{
			var isometryObject:IsometryObject = opaqueData as IsometryObject;
			if ( isometryObject != null )
			{
				isometryObject.OnMouseEvent( type );
			}
		}
		
		/** TODO:
			1: need to use it with some cashing - avoid creating animations for each similar object.
			2: create prope animations from MovieClip's
		*/
		private function CreateAnimation( singleResource:SingleResource, center:Point ): BliscAnimation
		{
			return BliscAnimation.FromMovieClip( singleResource.Display( _project ) as MovieClip, _project.FindResource( singleResource._resourcePath )._FPS, center, singleResource._name );
		}
		
		private function ComplexTemplateToBlisc( complex:ComplexTemplate ): BliscComplexTemplate
		{
			return new BliscComplexTemplate(
				complex._name,
				CreateAnimation( complex._singleResource, complex._center ),
				complex._disp,
				complex._center,
				complex._layer._name,
				complex._tiles.concat()
			);
		}
		
		private function AddUnit( unitDesc:UnitDesc ): void
		{
			var unit:Unit = new Unit( _main, unitDesc );
			_isometryObjects.push( unit );
			
			//TODO: lookup layer:
			var bliscUnit:BliscUnit = new BliscUnit( unit, _blisc, "common" );
			unit._view = bliscUnit;
			_blisc.AddObject( bliscUnit );
		}
		
		private function AddObject( objectInstance:ObjectInstance ): void
		{
			var bliscObjectTemplate:BliscObjectTemplate;
			
			if ( objectInstance._template is ComplexTemplate )
			{
				bliscObjectTemplate = ComplexTemplateToBlisc( objectInstance._template as ComplexTemplate );
			}
			else
			{
				var compound:CompoundTemplate = objectInstance._template as CompoundTemplate;
				var complexes:Vector.< BliscComplexWithinCompoundTemplate > = new Vector.< BliscComplexWithinCompoundTemplate >;
				for each ( var complexWithinCompound:ComplexWithinCompound in compound._consisting )
				{
					complexes.push( new BliscComplexWithinCompoundTemplate(
						ComplexTemplateToBlisc( complexWithinCompound._complex ),
						new Point( complexWithinCompound._tileDispX, complexWithinCompound._tileDispY ),
						Utils.FromIso( complexWithinCompound._tileDispX * _project.side, complexWithinCompound._tileDispY * _project.side, new Point )
					) );
				}
				bliscObjectTemplate = new BliscCompoundTemplate( compound._name, complexes );
			}
			
			var isometryObject:IsometryObject = new IsometryObject( objectInstance, _main );
			_isometryObjects.push( isometryObject );
			var bliscCompound:BliscCompound = new BliscCompound( isometryObject, _blisc, bliscObjectTemplate );
			isometryObject._view = bliscCompound;
			bliscCompound.SetTileX( objectInstance._tileCoords.x );
			bliscCompound.SetTileY( objectInstance._tileCoords.y );
			_blisc.AddObject( bliscCompound );
		}
		
		private static const GRID_DRAWER_LAYER_NAME:String = "grid_drawer_holder";
		
		/** Display specified map if it is not currently displayed yet. Abandon any other maps if there are.*/
		public function Display( map:Map ): void
		{
			if ( map == _displaying )
			{
				return;
			}
			
			Unload();
			
			_displaying = map;
			
			_main._mapPropertiesArea.enabled = true;
			_main._isoTileX.text = _main._isoTileY.text = "N/A";
			_main._drawBorder.selected = _displaying._drawBorder;
			_main._drawGrid.selected = _displaying._drawGrid;
			_main._clampToTile.selected = _displaying._clampToTiles;
			_main._unitsSpeed.text = _displaying._unitsSpeed.toString();
			
			_blisc = new Blisc( _bliscViewport, onIsometryMouseEvent, width, height, map._right + 100, map._down + 100, 5, _project.side );
			
			//adding an ability to draw map's grid:
			_blisc.AddLayer( GRID_DRAWER_LAYER_NAME );
			var drawerComplexTemplate:BliscComplexTemplate = new BliscComplexTemplate(
				"grid_drawer",
				null,
				new Point,
				new Point,
				GRID_DRAWER_LAYER_NAME,
				new Vector.< Point >
			);
			var drawerCompound:BliscCompound = new BliscCompound( null, _blisc, drawerComplexTemplate );
			_gridDrawer = new GridDrawer( map, width, height, _project );
			_gridDrawer._layerId = GRID_DRAWER_LAYER_NAME;
			drawerCompound._complexes[ 0 ]._complex = new BliscComplex( drawerComplexTemplate, _gridDrawer );
			_blisc.AddObject( drawerCompound );
			
			for each ( var layer:Layer in _project._data._layers )
			{
				_blisc.AddLayer( layer._name );
			}
			
			for each ( var objectInstance:ObjectInstance in map._instances )
			{
				AddObject( objectInstance );
			}
		}
		
		/** Remove currently displaying map (if there is such) and abandon it.*/
		public function Unload(): void
		{
			_main._mapPropertiesArea.enabled = false;
			_main._isoTileX.text = _main._isoTileY.text = "N/A";
			_main._unitsSpeed.text = "N/A";
			
			_selected = null;
			_main.ShowObjectProperties();
			
			_over = null;
			
			if ( _displaying == null )
			{
				return;
			}
			
			if ( _blisc != null )
			{
				for each ( var isometryObject:IsometryObject in _isometryObjects )
				{
					isometryObject.Destroy();
				}
				_isometryObjects.length = 0;
				
				_blisc.Destroy();
				_blisc = null;
			}
			
			_displaying = null;
			
			_dragging = null;
			_isDragging = null;
		}
		
		public function onDragEnter( event:DragEvent ): void
		{
			if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) ||
				event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) ||
				event.dragSource.hasFormat( Global.DRAG_FORMAG_UNIT_DESC ) )
			{
				DragManager.acceptDragDrop( event.currentTarget as UIComponent );
			}
		}
		
		public function onDragOver( event:DragEvent ): void
		{
			if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) || 
				event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) ||
				event.dragSource.hasFormat( Global.DRAG_FORMAG_UNIT_DESC ) )
			{
				DragManager.showFeedback( DragManager.COPY );
				return;
			}
			
			DragManager.showFeedback( DragManager.NONE );
		}
		
		public function onDragDrop( event:DragEvent ): void
		{
			if ( _displaying == null )
			{
				_main.PopUp( "Select some map first.", Main.POP_UP_ERROR );
				return;
			}
			
			if ( event.dragSource.hasFormat( Global.DRAG_FORMAG_UNIT_DESC ) )
			{
				AddUnit( event.dragSource.dataForFormat( Global.DRAG_FORMAG_UNIT_DESC ) as UnitDesc );
				return;
			}
			
			var addingTemplate:ObjectTemplate = null;
			
			if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) )
			{
				addingTemplate = event.dragSource.dataForFormat( Global.DRAG_FORMAT_COMPLEX_TEMPLATE ) as ObjectTemplate;
			}
			else if ( event.dragSource.hasFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) )
			{
				addingTemplate = event.dragSource.dataForFormat( Global.DRAG_FORMAT_COMPOUND_TEMPLATE ) as ObjectTemplate;
			}
			
			if ( addingTemplate != null )
			{
				var addingInstance:ObjectInstance = new ObjectInstance;
				addingInstance.Init( addingTemplate );
				
				_displaying._instances.push( addingInstance );
				
				AddObject( addingInstance );
			}
		}
		
		public function get displaying(): project_data.Map
		{
			return _displaying;
		}
		
		
		/** Object which was captured to drag.*/
		private var _dragging:IsometryObject = null;
		/** Did any mouse movement happened after mouse was pushed down.*/
		private var _wasDrag:Boolean = false;
		/** Mouse position (in local coordinates) relatively to dragging object when it was pushed down to start dragging or null if nothing is currently being dragged.*/
		private var _isDragging:Point = null;
		private function GetObj( e:MouseEvent, local:Point = null ): IsometryObject
		{
			if ( _blisc == null )
			{
				return null;
			}
			
			if ( local == null )
			{
				local = globalToLocal( new Point( e.stageX, e.stageY ) );
			}
			return _blisc.GetOpaqueDataAt( local.x, local.y ) as IsometryObject;
		}
		private function onMouseDown( e:MouseEvent ): void
		{
			if ( _blisc == null )
			{
				return;
			}
			
			var local:Point = globalToLocal( new Point( e.stageX, e.stageY ) );
			
			if ( _main._ctrlDown )
			{
				var newDragging:IsometryObject = GetObj( e, local );
				if ( newDragging != null )
				{
					_isDragging = new Point( local.x - newDragging._view.GetX(), local.y - newDragging._view.GetY() );
					_dragging = newDragging;
					_wasDrag = false;
					
					if ( _selected != null )
					{
						_selected.Deselect();
					}
					newDragging.Select();
					_main.ShowObjectProperties();
					_main._isometry.HideTip();
				}
			}
			else
			{
				_blisc.OnMouseDown( local.x, local.y );
			}
		}
		private function onMouseUp( e:MouseEvent ): void
		{
			if ( _blisc == null )
			{
				return;
			}
			
			_isDragging = null;
			
			var local:Point = globalToLocal( new Point( e.stageX, e.stageY ) );
			
			if ( _main._ctrlDown )
			{
			}
			else
			{
				_blisc.OnMouseUp( local.x, local.y );
			}
		}
		private function onMouseMove( e:MouseEvent ): void
		{
			if ( _blisc == null )
			{
				return;
			}
			
			var local:Point = globalToLocal( new Point( e.stageX, e.stageY ) );
			
			//displaying hovering tile coordinates:
			var iso:Point = new Point;
			_blisc.ScreenToIso( local.x, local.y, iso );
			_main._isoTileX.text = Math.floor( iso.x / _project.side ).toString();
			_main._isoTileY.text = Math.floor( iso.y / _project.side ).toString();
			
			if ( _main._ctrlDown && _isDragging != null )
			{
				var newIsoPos:Point = Utils.ToIso( local.x - _isDragging.x, local.y - _isDragging.y, new Point );
				var newTilePos:Point = new Point( newIsoPos.x / _project.side, newIsoPos.y / _project.side );
				if ( displaying._clampToTiles )
				{
					newTilePos.x = Math.round( newTilePos.x );
					newTilePos.y = Math.round( newTilePos.y );
				}
				_dragging._view.SetTileX( newTilePos.x );
				_dragging._view.SetTileY( newTilePos.y );
				_dragging._objectInstance._tileCoords.x = newTilePos.x;
				_dragging._objectInstance._tileCoords.y = newTilePos.y;
				_main.ShowObjectProperties();
			}
			else
			{
				_blisc.OnMouseMove( local.x, local.y );
			}
		}
		
		]]>
	</fx:Script>
	
	
</s:SpriteVisualElement>