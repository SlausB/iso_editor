<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               xmlns:mx="library://ns.adobe.com/flex/mx"
			   xmlns:ie="ie.*"
			   addedToStage="onInit()"
			   backgroundAlpha="0"
			   >
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<s:layout>
		<s:VerticalLayout />
	</s:layout>
	
	<mx:MenuBar id="_menuBar" labelField="@label" percentWidth="100" itemClick="onMenuItem(event)" >
		<fx:XMLList>
			<menuitem label="File" >
				<menuitem label="Open project..." id="open_project" />
				<menuitem label="Save project" id="save_project" enabled="false" />
				<menuitem label="Save project as..." id="save_project_as" />
				<menuitem label="Generate sources" id="generate_sources" />
			</menuitem>
			
			<menuitem label="Project" >
				<menuitem label="Properties..." id="project_properties" />
			</menuitem>
			
			<menuitem label="Preferences" >
				<menuitem label="Edit..." id="preferences_edit" />
			</menuitem>
			
			<menuitem label="Help" >
				<menuitem label="About" id="about" />
			</menuitem>
		</fx:XMLList>
	</mx:MenuBar>
	
	<!-- everything below menu: -->
	<mx:HDividedBox percentWidth="100" percentHeight="100" >
		
		<mx:VBox percentWidth="70" percentHeight="100" >
			
			<s:Group percentWidth="100" height="54" >
				<s:BorderContainer id="_mapPropertiesArea" x="6" percentWidth="100" percentHeight="100" enabled="false" >
					<s:Label x="10" y="10" text="Tile X:" />
					<s:Label x="60" y="10" id="_isoTileX" text="N/A" />
					
					<s:Label x="10" y="30" text="Tile Y:" />
					<s:Label x="60" y="30" id="_isoTileY" text="N/A" />
					
					<s:Label x="100" y="10" text="Draw border:" />
					<s:CheckBox x="180" y="5" id="_drawBorder" change="onDrawBorderFlagChange(event)" toolTip="Blue border at map bounds" />
					
					<s:Label x="100" y="30" text="Draw grid:" />
					<s:CheckBox x="162" y="25" id="_drawGrid" change="onDrawGridFlagChange(event)" toolTip="Is it need to draw very slow tile grid mesh" />
					
					<s:Label x="220" y="10" text="Clamp to tile:" />
					<s:CheckBox x="300" y="5" id="_clampToTile" change="onClampToTileFlagChange(event)" toolTip="Glue isometric objects to tiles while dragging" />
					
					<s:Label x="221" y="31" text="Units speed:" />
					<s:TextInput x="300" y="25" text="N/A" id="_unitsSpeed" restrict="-1234567890." change="onUnitsSpeedChange(event)" width="90" toolTip="Pixels per second units must move" />
					
					<s:Label x="350" y="10" text="Scale:" />
					<s:HGroup x="390" y="4" >
						<s:RadioButton id="_scale_1" width="30" groupName="scale" label="x1" click="onScale_1(event)" />
						<s:RadioButton id="_scale_2" width="30" groupName="scale" label="x2" click="onScale_2(event)" />
						<s:RadioButton id="_scale_3" width="30" groupName="scale" label="x3" click="onScale_3(event)" />
						<s:RadioButton id="_scale_4" width="30" groupName="scale" label="x4" click="onScale_4(event)" />
					</s:HGroup>
					
					<s:Label x="402" y="33" text="Through:" />
					<s:CheckBox id="_through" x="456" y="28" toolTip="Choose deepest selectable object under mouse and make remaining overlapping transparent" change="onThroughChange(event)" />
					
					<s:Label x="484" y="33" text="Move:" />
					<s:CheckBox id="_move" x="520" y="28" toolTip="Toggle to enter moving mode where objects will be moved by mouse instead of viewport" />
					
					<s:VGroup x="550" y="4" >
						<s:RadioButton id="_tipGraphics" groupName="tip" label="Graphics" selected="true" toolTip="Show objects selection tooltip using their graphics" />
						<s:RadioButton id="_tipSpace" groupName="tip" label="Space" toolTip="Show objects selection using their any space regions" />
					</s:VGroup>
					
					<s:Button id="_reloadMapButton" x="640" y="4" label="Reload" toolTip="Recreate isometric objects accordingly last changes within templates and compounds" click="onReloadMap(event)" enabled="false" />
					
					<s:Label text="Strict move:" x="640" y="35" />
					<s:CheckBox id="_strictMove" x="714" y="31" toolTip="Move units from tile to tile passing around restricted surfaces nstead of ghost-like hovering." />
					
					<s:Label text="Stroll:" x="724" y="10" />
					<s:CheckBox id="_stroll" x="763" y="6" toolTip="Allow units randomly walking around." selected="true" />
				</s:BorderContainer>
			</s:Group>
			
			<mx:VDividedBox percentWidth="100" percentHeight="100" >
				
				<s:Group percentWidth="100" percentHeight="80" dragEnter="onIsometryDragEnter(event)" dragOver="onIsometryDragOver(event)" dragDrop="onIsometryDragDrop(event)" >
					<ie:Isometry id="_isometry" percentWidth="100" percentHeight="100" />
				</s:Group>
				
				<s:Scroller percentWidth="100" percentHeight="20" >
					<s:Group id="_resources_preview_holder" resize="onResourcesPreviewHolderResize(event)" />
				</s:Scroller>
				
			</mx:VDividedBox>
		</mx:VBox>
		
		<mx:VDividedBox percentWidth="30" percentHeight="100" >
			<s:Group percentWidth="100" percentHeight="20" >
				<s:Rect percentWidth="100" percentHeight="100" >
					<s:stroke>
						<s:SolidColorStroke color="0x000000" weight="2" />
					</s:stroke>
				</s:Rect>
				
				<ie:IsometricPreview id="_isometricPreview" />
			</s:Group>
			
			<mx:Accordion percentWidth="100" percentHeight="80" creationPolicy="all" >
				
				<mx:VBox label="Resources" percentWidth="100" percentHeight="100" >
					<s:List id="_resources_list" percentWidth="100" percentHeight="100" borderVisible="false" changing="onResourceChoice(event)" contextMenu="onResourcesContextMenu(event)" >
						<s:ArrayList id="_resources_list_data_provider" />
					</s:List>
				</mx:VBox>
				
				<mx:VBox label="Templates" percentWidth="100" percentHeight="100" >
					<s:DataGrid id="_templates_table" percentWidth="100" percentHeight="100" borderVisible="false" contextMenu="onTemplatesContextMenu(event)" mouseDown="onTemplatesMouseDown(event)" mouseUp="onTemplatesMouseUp(event)" mouseMove="onTemplatesMouseMove(event)" selectionChanging="onTemplateChoice(event)" >
						<s:columns>
							<s:ArrayList>
								<s:GridColumn dataField="name" headerText="Name" />
								<s:GridColumn dataField="used" headerText="Used" width="60" />
								<s:GridColumn headerText="View" sortable="false" width="60" >
									<s:itemRenderer>
										<fx:Component>
											<s:GridItemRenderer>
												<s:SpriteVisualElement id="_view" />
												<fx:Script>
													<![CDATA[
	import com.junkbyte.console.Cc;
	import utils.Utils;
														override public function prepare( hasBeenRecycled:Boolean ): void
														{
															if ( data != null )
															{
																Utils.RemoveAllChildren( _view );
																var view:flash.display.DisplayObject = data.view;
																Utils.CenterItself( view );
																view.y += 13;
																view.x += 4 + ( view.getBounds( view ).width / 2.0 );
																_view.addChild( view );
															}
														}
													]]>
												</fx:Script>
											</s:GridItemRenderer>
										</fx:Component>
									</s:itemRenderer>
								</s:GridColumn>
							</s:ArrayList>
						</s:columns>
						<mx:ArrayCollection id="_templates_table_data_provider" />
					</s:DataGrid>
				</mx:VBox>
				
				<mx:VBox label="Compounds" percentWidth="100" percentHeight="100" >
					<s:DataGrid id="_compounds_table" percentWidth="100" percentHeight="100" borderVisible="false" contextMenu="onCompoundsContextMenu(event)" mouseDown="onCompoundsMouseDown(event)" mouseUp="onCompoundsMouseUp(event)" mouseMove="onCompoundsMouseMove(event)" selectionChanging="onCompoundsChoice(event)" >
						<s:columns>
							<s:ArrayList>
								<s:GridColumn dataField="name" headerText="Name" />
								<s:GridColumn dataField="used" headerText="Used" width="60" />
								<s:GridColumn headerText="View" sortable="false" width="60" >
									<s:itemRenderer>
										<fx:Component>
											<s:GridItemRenderer>
												<s:SpriteVisualElement id="_view" />
												<fx:Script>
													<![CDATA[
	import com.junkbyte.console.Cc;
	import utils.Utils;
														override public function prepare( hasBeenRecycled:Boolean ): void
														{
															if ( data != null )
															{
																Utils.RemoveAllChildren( _view );
																var view:flash.display.DisplayObject = data.view;
																Utils.CenterItself( view );
																view.y += 13;
																view.x += 4 + ( view.getBounds( view ).width / 2.0 );
																_view.addChild( view );
															}
														}
													]]>
												</fx:Script>
											</s:GridItemRenderer>
										</fx:Component>
									</s:itemRenderer>
								</s:GridColumn>
							</s:ArrayList>
						</s:columns>
						<mx:ArrayCollection id="_compounds_table_data_provider" />
					</s:DataGrid>
				</mx:VBox>
				
				<mx:VBox label="Units" percentWidth="100" percentHeight="100" >
					<s:List id="_units_list" percentWidth="100" percentHeight="100" borderVisible="false" changing="onUnitChoice(event)" mouseDown="onUnitsMouseDown(event)" mouseUp="onUnitsMouseUp(event)" mouseMove="onUnitsMouseMove(event)" contextMenu="onUnitsContextMenu(event)">
						<s:ArrayList id="_units_list_data_provider" />
					</s:List>
				</mx:VBox>
				
				<mx:VBox label="Maps" percentWidth="100" percentHeight="100" >
					<s:List id="_maps_list" percentWidth="100" percentHeight="100" borderVisible="false" changing="onMapsChoice(event)" contextMenu="onMapsContextMenu(event)" >
						<s:ArrayList id="_maps_list_data_provider" />
					</s:List>
				</mx:VBox>
				
				<mx:VBox label="Layers" percentWidth="100" percentHeight="100" >
					<s:List id="_layers_list" percentWidth="100" percentHeight="100" borderVisible="false" changing="onLayersChoice(event)" contextMenu="onLayersContextMenu(event)" >
						<s:ArrayList id="_layers_list_data_provider" />
					</s:List>
				</mx:VBox>
				
				<mx:VBox id="_instanceProperties" label="Instance properties" enabled="false" paddingTop="10" paddingLeft="10" verticalGap="20" >
					<mx:VBox>
						<mx:HBox>
							<mx:Label text="Name:" />
							<mx:Label id="_objectName" />
						</mx:HBox>
					</mx:VBox>
					<mx:VBox>
						<mx:HBox >
							<mx:Text text="iso X:" />
							<mx:TextInput id="_objectIsoX" width="60" restrict="-1234567890." change="onObjectIsoXChange(event)" />
						</mx:HBox>
						<mx:HBox>
							<mx:Text text="iso Y:" />
							<mx:TextInput id="_objectIsoY" width="60" restrict="-1234567890." change="onObjectIsoYChange(event)" />
						</mx:HBox>
					</mx:VBox>
					
					<mx:VBox>
						<mx:HBox >
							<mx:Text text="tile X:" />
							<mx:TextInput id="_objectTileX" width="60" restrict="-1234567890." change="onObjectTileXChange(event)" />
						</mx:HBox>
						<mx:HBox>
							<mx:Text text="tile Y:" />
							<mx:TextInput id="_objectTileY" width="60" restrict="-1234567890." change="onObjectTileYChange(event)" />
						</mx:HBox>
					</mx:VBox>
					
					<mx:VBox>
						<mx:HBox >
							<mx:Text text="flat X:" />
							<mx:TextInput id="_objectFlatX" width="60" restrict="-1234567890." change="onObjectFlatXChange(event)" />
						</mx:HBox>
						<mx:HBox>
							<mx:Text text="flat Y:" />
							<mx:TextInput id="_objectFlatY" width="60" restrict="-1234567890." change="onObjectFlatYChange(event)" />
						</mx:HBox>
					</mx:VBox>
				</mx:VBox>
				
				<mx:VBox label="Regions" percentWidth="100" percentHeight="100" >
					<s:List id="_regions_list" percentWidth="100" percentHeight="100" borderVisible="false" changing="onRegionChoice(event)" contextMenu="onRegionContextMenu(event)" >
						<s:ArrayList />
					</s:List>
				</mx:VBox>
				
			</mx:Accordion>
			
		</mx:VDividedBox>
		
	</mx:HDividedBox>
	
	
	<fx:Script>
		<![CDATA[
import adobe.utils.CustomActions;
import blisc.core.Blisc;
import blisc.core.BliscAnimation;
import blisc.core.BliscSprite;
import blisc.templates.BliscMapTemplate;
import blisc.templates.BliscRegion;
import blisc.templates.BliscUnitView;
import com.junkbyte.console.Cc;
import flash.display.DisplayObject;
import flash.display.DisplayObjectContainer;
import flash.display.InteractiveObject;
import flash.display.Loader;
import flash.display.LoaderInfo;
import flash.display.MovieClip;
import flash.display.Sprite;
import flash.errors.IOError;
import flash.events.ContextMenuEvent;
import flash.events.Event;
import flash.events.IOErrorEvent;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.events.SecurityErrorEvent;
import flash.filesystem.File;
import flash.filesystem.FileMode;
import flash.filesystem.FileStream;
import flash.geom.Point;
import flash.net.FileFilter;
import flash.net.FileReference;
import flash.net.URLLoader;
import flash.net.URLRequest;
import flash.system.ApplicationDomain;
import flash.ui.ContextMenu;
import flash.utils.ByteArray;
import flash.utils.getQualifiedClassName;
import ie.ConfirmationWindow;
import ie.EditingMapWindow;
import ie.EditingPreferencesWindow;
import ie.SourcesGenerationResult;
import list_items.CompoundTableItem;
import list_items.LayerListItem;
import list_items.ListItem;
import list_items.MapListItem;
import list_items.RegionListItem;
import list_items.TemplateTableItem;
import list_items.UnitListItem;
import mx.collections.ArrayCollection;
import mx.collections.ArrayList;
import mx.containers.TitleWindow;
import mx.controls.Alert;
import mx.controls.List;
import mx.controls.Menu;
import mx.core.DragSource;
import mx.core.FlexTextField;
import mx.core.UIComponent;
import mx.events.DragEvent;
import mx.events.IndexChangedEvent;
import mx.events.MenuEvent;
import mx.graphics.codec.PNGEncoder;
import mx.managers.DragManager;
import mx.managers.PopUpManager;
import org.osmf.media.LoadableElementBase;
import project_data.AnimationProperties;
import project_data.ComplexTemplate;
import project_data.ComplexWithinCompound;
import project_data.CompoundTemplate;
import project_data.Layer;
import project_data.Map;
import project_data.ObjectInstance;
import project_data.ObjectTemplate;
import project_data.Region;
import project_data.RegionWithinComplex;
import project_data.Resource;
import project_data.SingleResource;
import project_data.UnitProperties;
import ru.etcs.utils.getDefinitionNames;
import spark.components.DataGroup;
import spark.components.gridClasses.GridItemRenderer;
import spark.components.gridClasses.IGridItemRenderer;
import spark.components.Label;
import spark.core.IContentLoader;
import spark.events.GridSelectionEvent;
import spark.events.IndexChangeEvent;
import spark.skins.spark.DefaultItemRenderer;
import utils.Utils;
import ie.EditingTemplateWindow;
import ie.EditingLayerWindow;
import ie.EditingProjectWindow;
import ie.EditingUnitWindow;
import ie.EditingRegionWindow;
import view.Projection;

		public var _projectPath : String = null;
		
		public var _project : Project;
		
		public var _resourcesPreview : ResourcesPreview = new ResourcesPreview;
		
		/** Currently displayed map and layers of which are displayed within "layers list".*/
		public var _chosenMap : Map = null;
		
		public var _qDown : Boolean = false;
		
		/** Is it need to clamp complex templates within compound editing window.*/
		public static var _clampTemplatesToTile : Boolean = false;
		
		/** Currently opened editing window if not null.*/
		public var _editingTemplateWindow : EditingTemplateWindow = null;
		
		/** Last chosen surface and space to prechoose it when window is displayed. Null if no such.*/
		public var _lastSurface : Region = null;
		public var _lastSpace : Region = null;
		
		/** True if any modification was made with editor and other project file cannot be loaded - editor must be restarted.*/
		public var _changeMade : Boolean = false;
		
		/** How much windows currently displayed - isometry will be mouse interactive only if there are 0.*/
		public var _windows : int = 0;
		
		
		public function onInit( ... args ) : void
		{
			_project = new Project( this );
			
			Cc.config.commandLineAllowed = true; // Enables full commandLine features
			Cc.config.maxLines = 3000; // change maximum log lines to 3000, default is 1000
			Cc.config.defaultStackDepth = 10;
			Cc.startOnStage( stage, "`" );
			//width and hight can be settled only AFTER console is shown:
			Cc.width = 700;
			Cc.height = 400;
			
			_resources_preview_holder.addElement( _resourcesPreview );
			
			_isometry.Init( _project, this );
			
			stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyboardEvent );
			stage.addEventListener( KeyboardEvent.KEY_UP, onKeyboardEvent );
		}
		
		private function onKeyboardEvent( e : KeyboardEvent ) : void
		{
			switch ( e.keyCode )
			{
				//esc:
				case 27:
					_isometry.CancelPositioning();
					break;
				
				//del:
				case 46:
					//remove currently selected complex within compound editing window:
					if ( _editingTemplateWindow != null )
					{
						if ( _editingTemplateWindow._compound != null )
						{
							if ( _editingTemplateWindow._lastDragged != null )
							{
								_editingTemplateWindow._lastDragged.parent.removeChild( _editingTemplateWindow._lastDragged );
								
								for ( var i : int = 0; i < _editingTemplateWindow._templates.length; ++i )
								{
									if ( _editingTemplateWindow._templates[ i ] == _editingTemplateWindow._lastDragged )
									{
										_editingTemplateWindow._templates.splice( i, 1 );
										break;
									}
								}
								
								_editingTemplateWindow._lastDragged = null;
							}
						}
					}
					//remove currently selected object from map:
					else if ( _isometry._selected != null && _isometry.displaying != null )
					{
						RemoveObjectFromMap( _isometry._selected._objectInstance, _isometry.displaying );
					}
					break;
				
				//ctrl+f to simulate program crash to check if editor is run in debug mode:
				case 70:
					if ( e.ctrlKey )
					{
						var falling : Sprite = null;
						falling.addChild( null );
					}
					break;
				
				//q:
				case 81:
					_qDown = e.type == KeyboardEvent.KEY_DOWN;
					break;
			}
		}
		
		public function UpdateUsage( template : ObjectTemplate ) : void
		{
			if ( template is ComplexTemplate )
			{
				var templateTableItem : TemplateTableItem = ListItem.FindListItem( template, _templates_table.dataProvider ) as TemplateTableItem;
				if ( templateTableItem == null )
				{
					Cc.error( "E: Main.UpdateUsage(): TemplateTableItem was NOT found." );
				}
				else
				{
					templateTableItem.UpdateUsage( this );
					_templates_table.dataProvider.itemUpdated( templateTableItem );
				}
			}
			else if ( template is CompoundTemplate )
			{
				var compoundTableItem : CompoundTableItem = ListItem.FindListItem( template, _compounds_table.dataProvider ) as CompoundTableItem;
				if ( compoundTableItem == null )
				{
					Cc.error( "E: Main.UpdateUsage(): CompoundTableItem was NOT found." );
				}
				else
				{
					compoundTableItem.UpdateUsage( this );
					_compounds_table.dataProvider.itemUpdated( compoundTableItem );
				}
			}
		}
		
		public function RemoveObjectFromMap( objectInstance : ObjectInstance, map : Map, updateUsage : Boolean = true ): void
		{
			//if removing object from currently selected map:
			if ( _isometry.displaying == map )
			{
				var selected : IsometryObject = _isometry._selected;
				
				if ( selected != null && selected._objectInstance == objectInstance )
				{
					selected.Deselect();
					_isometry._selected = null;
				}
				
				if ( _isometry._over != null && _isometry._over._objectInstance == objectInstance )
				{
					_isometry._over.Out();
					_isometry._over = null;
				}
				
				//remove from displaying:
				for ( var isometryObjectIndex : int = 0; isometryObjectIndex < _isometry._isometryObjects.length; ++isometryObjectIndex )
				{
					var isometryObject : IsometryObject = _isometry._isometryObjects[ isometryObjectIndex ];
					if ( isometryObject._objectInstance == objectInstance )
					{
						_isometry._isometryObjects.splice( isometryObjectIndex, 1 );
						isometryObject.Destroy();
						break;
					}
				}
			}
			
			//remove from map's objects:
			for ( var mapObjectIndex : int = 0; mapObjectIndex < map._instances.length; ++mapObjectIndex )
			{
				if ( map._instances[ mapObjectIndex ] == objectInstance )
				{
					map._instances.splice( mapObjectIndex, 1 );
					break;
				}
			}
			
			if ( updateUsage )
			{
				if ( objectInstance is ComplexTemplate )
				{
					var templateTableItem : TemplateTableItem = ListItem.FindListItem( objectInstance._template, _templates_table.dataProvider ) as TemplateTableItem;
					if ( templateTableItem == null )
					{
						Cc.error( "E: Main.RemoveObjectFromMap(): TemplateTableItem was NOT found." );
					}
					else
					{
						templateTableItem.UpdateUsage( this );
						_templates_table.dataProvider.itemUpdated( templateTableItem );
					}
				}
				else if ( objectInstance is CompoundTemplate )
				{
					var compoundTableItem:CompoundTableItem = ListItem.FindListItem( objectInstance._template, _compounds_table.dataProvider ) as CompoundTableItem;
					if ( compoundTableItem == null )
					{
						Cc.error( "E: Main.RemoveObjectFromMap(): CompoundTableItem was NOT found." );
					}
					else
					{
						compoundTableItem.UpdateUsage( this );
						_compounds_table.dataProvider.itemUpdated( compoundTableItem );
					}
				}
			}
		}
		
		public function onResourceChoice( e : IndexChangeEvent ) : void
		{
			var resource : Resource = ( ( e.target as spark.components.List ).dataProvider as ArrayList ).source[ e.newIndex ].resource as Resource;
			_resourcesPreview.Display( resource, _project );
		}
		public function onTemplateChoice( e : GridSelectionEvent ) : void
		{
			var templateTableItem : TemplateTableItem = _templates_table.dataProvider.getItemAt( e.selectionChange.rowIndex ) as TemplateTableItem;
			_isometricPreview.Display( templateTableItem.template, _project );
		}
		public function onCompoundsChoice( e : GridSelectionEvent ) : void
		{
			var compoundTableItem : CompoundTableItem = _compounds_table.dataProvider.getItemAt( e.selectionChange.rowIndex ) as CompoundTableItem;
			_isometricPreview.Display( compoundTableItem.compound, _project );
		}
		public function onUnitChoice( e : IndexChangeEvent ) : void
		{
			trace( "unit" );
		}
		public function onMapsChoice( e : IndexChangeEvent ) : void
		{
			_chosenMap = ( ( ( e.target as spark.components.List ).dataProvider as ArrayList ).source[ e.newIndex ] as MapListItem ).map;
			_isometry.Display( _chosenMap );
		}
		public function onLayersChoice( e : IndexChangeEvent ) : void
		{
			trace( "layer" );
		}
		
		public var _resourcesContextMenu : Menu = null;
		public function onResourcesContextMenu( e : MouseEvent ) : void
		{
			//for now we're ignoring right clicks on resource elements (menus like "Remove" can be added at future):
			if ( ( e.target is DataGroup ) == false )
			{
				return;
			}
			
			if ( _resourcesContextMenu != null && _resourcesContextMenu.visible == true )
			{
				_resourcesContextMenu.x = e.stageX;
				_resourcesContextMenu.y = e.stageY;
				return;
			}
			_resourcesContextMenu = Menu.createMenu( null, _resourcesContextMenuData );
			_resourcesContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "add_resource":
						_changeMade = true;
						_project.AddResource();
						break;
				}
			} );
			_resourcesContextMenu.show( e.stageX, e.stageY );
		}
		[Bindable]
		public var _resourcesContextMenuData:Array =
		[
			{ label:"Add resource...", id:"add_resource" }
		];
		
		private function FindListItem( e:MouseEvent, type:Class ): *
		{
			if ( e.target is spark.components.Label )
			{
				var label:spark.components.Label = e.target as spark.components.Label;
				var dir:DefaultItemRenderer = label.parent as DefaultItemRenderer;
				if ( dir == null )
				{
					Cc.error( "E: Main.FindListItem(): wrong expectations." );
					return null;
				}
				else
				{
					var looking:* = dir.data as type;
					if ( looking == null )
					{
						Cc.error( "E: Main.FindListItem(): wrong data." );
						return null;
					}
					else
					{
						return looking;
					}
				}
			}
			return null;
		}
		
		private function FindTableItem( e:MouseEvent ): ListItem
		{
			var gir:IGridItemRenderer = Utils.FindParentByType( e.target as DisplayObject, IGridItemRenderer ) as IGridItemRenderer;
			if ( gir != null )
			{
				return gir.data as ListItem;
			}
			return null;
		}
		
		public var _templatesContextMenu : Menu = null;
		private function onTemplatesContextMenu( e : MouseEvent ) : void
		{
			var thisOne : Main = this;
			
			if ( _templatesContextMenu != null )
			{
				_templatesContextMenu.hide();
				_templatesContextMenu = null;
			}
			
			var menuData:Array = [ { label : "Add template...", id : "add_template" } ];
			
			var gridItemRenderer : IGridItemRenderer = Utils.FindParentByType( e.target as DisplayObject, IGridItemRenderer ) as IGridItemRenderer;
			if ( gridItemRenderer != null )
			{
				var templateTableItem : TemplateTableItem = gridItemRenderer.data as TemplateTableItem;
				if ( templateTableItem != null )
				{
					menuData = menuData.concat(
						[ { label : "Edit...", id : "edit", template : templateTableItem.template } ],
						[ { label : "Delete", id : "delete", template : templateTableItem.template } ],
						[ { label : "Position", id : "position", template : templateTableItem.template } ],
						[ { label : "Duplicate", id : "duplicate", template : templateTableItem.template } ]
					);
				}
			}
			
			_templatesContextMenu = Menu.createMenu( null, menuData );
			_templatesContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "add_template":
						_changeMade = true;
						AddTemplate();
						break;
					
					case "edit":
						_editingTemplateWindow = PopUpManager.createPopUp( thisOne, EditingTemplateWindow, false ) as EditingTemplateWindow;
						_editingTemplateWindow.Init( _project, menuEvent.item.template, thisOne );
						PopUpManager.centerPopUp( _editingTemplateWindow );
						break;
					
					case "delete":
						var templatesDependence : TemplatesDependence = _project.ResolveTemplatesDependence( menuEvent.item.template );
						if ( templatesDependence._compounds.length > 0 || templatesDependence._maps.length > 0 )
						{
							var confirmationWindow : ConfirmationWindow = PopUpManager.createPopUp( thisOne, ConfirmationWindow, true ) as ConfirmationWindow;
							confirmationWindow.Init(
								_project,
								thisOne,
								"Removing template \"" + menuEvent.item.template._name + "\" will cause " + templatesDependence._instances.toString() + " map objects to remove from " + templatesDependence._maps.length + " maps and " + templatesDependence._compounds.length.toString() + " compound templates to change. Are you sure?",
								function(): void
								{
									RemoveTemplate( templatesDependence );
								} );
							PopUpManager.centerPopUp( confirmationWindow );
						}
						//otherwise nobody cares - just remove it and forget about it:
						else
						{
							RemoveTemplate( templatesDependence );
						}
						break;
					
					case "position":
						Position( menuEvent.item.template );
						break;
					
					case "duplicate":
						_changeMade = true;
						AddTemplate( menuEvent.item.template.clone() );
						break;
				}
			} );
			_templatesContextMenu.show( e.stageX, e.stageY );
		}
		
		public function RemoveTemplate( templatesDependence : TemplatesDependence ): void
		{
			//from the representating list:
			var templateTableItem : TemplateTableItem = ListItem.FindListItem( templatesDependence._template, _templates_table.dataProvider ) as TemplateTableItem;
			if ( templateTableItem != null )
			{
				_templates_table_data_provider.removeItemAt( _templates_table_data_provider.getItemIndex( templateTableItem ) );
			}
			
			//from project's array:
			for ( var i : int = 0; i < _project._data._objects.length; ++i )
			{
				if ( _project._data._objects[ i ] == templatesDependence._template )
				{
					_project._data._objects.splice( i, 1 );
					break;
				}
			}
			
			//all objects from all maps:
			for each ( var map : TemplatesMapDependence in templatesDependence._maps )
			{
				for each ( var objectInstance : ObjectInstance in map._instances )
				{
					RemoveObjectFromMap( objectInstance, map._map, false );
				}
			}
			
			//all instances from all compounds:
			for each ( var compound : CompoundTemplate in templatesDependence._compounds )
			{
				for ( var ti : int = 0; ti < compound._consisting.length; ++ti )
				{
					if ( compound._consisting[ ti ]._complex == templatesDependence._template )
					{
						compound._consisting.splice( ti, 1 );
						--ti;
					}
				}
				
				var compoundTableItem : CompoundTableItem = ListItem.FindListItem( compound, _compounds_table.dataProvider ) as CompoundTableItem;
				if ( compoundTableItem != null )
				{
					compoundTableItem.UpdateView( this );
					_compounds_table.dataProvider.itemUpdated( compoundTableItem );
				}
			}
			
			_reloadMapButton.enabled = true;
		}
		
		public var _compoundsContextMenu:Menu = null;
		private function onCompoundsContextMenu( e:MouseEvent ): void
		{
			var thisOne:Main = this;
			
			if ( _compoundsContextMenu != null )
			{
				_compoundsContextMenu.hide();
				_compoundsContextMenu = null;
			}
			
			var menuData : Array = [ { label:"Add compound...", id:"add_compound" } ];
			
			var gridItemRenderer : IGridItemRenderer = Utils.FindParentByType( e.target as DisplayObject, IGridItemRenderer ) as IGridItemRenderer;
			if ( gridItemRenderer != null )
			{
				var compoundTableItem : CompoundTableItem = gridItemRenderer.data as CompoundTableItem;
				if ( compoundTableItem != null )
				{
					menuData = menuData.concat(
						[ { label : "Edit...", id : "edit", compound : compoundTableItem.compound } ],
						[ { label : "Delete", id : "delete", compound : compoundTableItem.compound } ],
						[ { label : "Position...", id : "position", compound : compoundTableItem.compound } ],
						[ { label : "Duplicate", id : "duplicate", compound : compoundTableItem.compound } ]
					);
				}
			}
			
			_compoundsContextMenu = Menu.createMenu( null, menuData );
			_compoundsContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "add_compound":
						_changeMade = true;
						AddCompound();
						break;
					
					case "edit":
						_editingTemplateWindow = PopUpManager.createPopUp( thisOne, EditingTemplateWindow, false ) as EditingTemplateWindow;
						_editingTemplateWindow.Init( _project, menuEvent.item.compound, thisOne );
						PopUpManager.centerPopUp( _editingTemplateWindow );
						break;
					
					case "delete":
						var compoundsDependence : CompoundsDependence = _project.ResolveCompoundsDependence( menuEvent.item.compound );
						if ( compoundsDependence._instances > 0 )
						{
							var confirmationWindow : ConfirmationWindow = PopUpManager.createPopUp( thisOne, ConfirmationWindow, true ) as ConfirmationWindow;
							confirmationWindow.Init(
								_project,
								thisOne,
								"Removing compound template \"" + menuEvent.item.compound._name + "\" will cause " + compoundsDependence._instances.toString() + " map objects to remove from " + compoundsDependence._maps.length + " maps. Are you sure?",
								function(): void
								{
									RemoveCompound( compoundsDependence );
								} );
							PopUpManager.centerPopUp( confirmationWindow );
						}
						//otherwise nobody cares - just remove it and forget about it:
						else
						{
							RemoveCompound( compoundsDependence );
						}
						break;
					
					case "position":
						Position( menuEvent.item.compound );
						break;
					
					case "duplicate":
						_changeMade = true;
						AddCompound( menuEvent.item.compound.clone() );
						break;
				}
			} );
			_compoundsContextMenu.show( e.stageX, e.stageY );
		}
		
		private function RemoveCompound( compoundsDependence : CompoundsDependence ): void
		{
			//from the representating list:
			var compoundTableItem : CompoundTableItem = ListItem.FindListItem( compoundsDependence._compound, _compounds_table.dataProvider ) as CompoundTableItem;
			if ( compoundTableItem != null )
			{
				_compounds_table_data_provider.removeItemAt( _compounds_table_data_provider.getItemIndex( compoundTableItem ) );
			}
			
			//from project's array:
			for ( var i : int = 0; i < _project._data._objects.length; ++i )
			{
				if ( _project._data._objects[ i ] == compoundsDependence._compound )
				{
					_project._data._objects.splice( i, 1 );
					break;
				}
			}
			
			//all objects from all maps:
			for each ( var map : CompoundsMapDependence in compoundsDependence._maps )
			{
				for each ( var objectInstance : ObjectInstance in map._instances )
				{
					RemoveObjectFromMap( objectInstance, map._map, false );
				}
			}
		}
		
		private var _mapsContextMenu:Menu = null;
		public var _singleMapContextMenu:Menu = null;
		private function onMapsContextMenu( e:MouseEvent ): void
		{
			if ( e.target is spark.components.Label )
			{
				var mapListItem:MapListItem = FindListItem( e, MapListItem ) as MapListItem;
				if ( mapListItem != null )
				{
					ShowMapContextMenu( mapListItem.map, e.stageX, e.stageY );
				}
				return;
			}
			else if ( ( e.target is DataGroup ) == false )
			{
				return;
			}
			
			if ( _mapsContextMenu != null && _mapsContextMenu.visible == true )
			{
				_mapsContextMenu.x = e.stageX;
				_mapsContextMenu.y = e.stageY;
				return;
			}
			_mapsContextMenu = Menu.createMenu( null, _mapsContextMenuData );
			_mapsContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "add_map":
						_changeMade = true;
						AddMap();
						break;
				}
			} );
			_mapsContextMenu.show( e.stageX, e.stageY );
		}
		[Bindable]
		public var _mapsContextMenuData:Array =
		[
			{ label:"Add map...", id:"add_map" }
		];
		private function ShowMapContextMenu( map:Map, x:Number, y:Number ): void
		{
			var thisOne:Main = this;
			
			if ( _singleMapContextMenu != null )
			{
				_singleMapContextMenu.hide();
				_singleMapContextMenu = null;
			}
			
			_singleMapContextMenu = Menu.createMenu( null, [ { label: "Edit...", id: "edit", map: map } ] );
			_singleMapContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( singleMapMenuEvent:MenuEvent ): void
			{
				switch ( singleMapMenuEvent.item.id )
				{
					case "edit":
						var editingMapWindow:EditingMapWindow = PopUpManager.createPopUp( thisOne, EditingMapWindow, false ) as EditingMapWindow;
						editingMapWindow.Init( _project, thisOne, map );
						PopUpManager.centerPopUp( editingMapWindow );
						break;
				}
			} );
			_singleMapContextMenu.show( x, y );
		}
		
		private var _layersContextMenu:Menu = null;
		private var _singleLayerContextMenu:Menu = null;
		private function onLayersContextMenu( e:MouseEvent ): void
		{
			if ( e.target is spark.components.Label )
			{
				var label:spark.components.Label = e.target as spark.components.Label;
				var dir:DefaultItemRenderer = label.parent as DefaultItemRenderer;
				if ( dir == null )
				{
					Cc.error( "E: Main.onLayersContextMenu(): wrong expectations." );
				}
				else
				{
					var layerListItem:LayerListItem = dir.data as LayerListItem;
					if ( layerListItem == null )
					{
						Cc.error( "E: Main.onLayersContextMenu(): wrong data." );
					}
					else
					{
						ShowSingleLayerContextMenu( layerListItem, e.stageX, e.stageY );
					}
				}
				return;
			}
			else if ( ( e.target is DataGroup ) == false )
			{
				return;
			}
			
			if ( _layersContextMenu != null && _layersContextMenu.visible == true )
			{
				_layersContextMenu.x = e.stageX;
				_layersContextMenu.y = e.stageY;
				return;
			}
			_layersContextMenu = Menu.createMenu( null, _layersContextMenuData );
			_layersContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "add_layer":
						_changeMade = true;
						AddLayer();
						break;
				}
			} );
			_layersContextMenu.show( e.stageX, e.stageY );
		}
		[Bindable]
		public var _layersContextMenuData:Array =
		[
			{ label:"Add layer...", id:"add_layer" }
		];
		private function ShowSingleLayerContextMenu( layerListItem:LayerListItem, x:Number, y:Number ): void
		{
			var thisOne:Main = this;
			
			if ( _singleLayerContextMenu != null )
			{
				_singleLayerContextMenu.hide();
				_singleLayerContextMenu = null;
			}
			
			var mdp:Object = [ { label: "Edit...", id: "edit", layerListItem: layerListItem } ];
			if ( layerListItem.index > 0 )
			{
				mdp.push( { label: "Move up (deeper)", id: "move_up", layerListItem: layerListItem } );
			}
			if ( layerListItem.index < ( _project._data._layers.length - 1 ) )
			{
				mdp.push( { label: "Move down (closer)", id: "move_down", layerListItem: layerListItem } );
			}
			
			_singleLayerContextMenu = Menu.createMenu( null, mdp );
			_singleLayerContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( singleLayerMenuEvent:MenuEvent ): void
			{
				var layerListItem_withinMenu:LayerListItem = singleLayerMenuEvent.item.layerListItem;
				
				switch ( singleLayerMenuEvent.item.id )
				{
					case "edit":
						var editingLayerWindow : EditingLayerWindow = PopUpManager.createPopUp( thisOne, EditingLayerWindow, false ) as EditingLayerWindow;
						editingLayerWindow.Init( _project, layerListItem_withinMenu.layer, thisOne );
						PopUpManager.centerPopUp( editingLayerWindow );
						break;
					
					case "move_up":
						const previousIndex:int = layerListItem_withinMenu.index - 1;
						var previous:Layer = _project._data._layers[ previousIndex ];
						_project._data._layers[ previousIndex ] = layerListItem_withinMenu.layer;
						_project._data._layers[ layerListItem_withinMenu.index ] = previous;
						UpdateLayersList();
						_isometry.Reinit();
						break;
					
					case "move_down":
						const nextIndex:int = layerListItem_withinMenu.index + 1;
						var next:Layer = _project._data._layers[ nextIndex ];
						_project._data._layers[ nextIndex ] = layerListItem_withinMenu.layer;
						_project._data._layers[ layerListItem_withinMenu.index ] = next;
						UpdateLayersList();
						_isometry.Reinit();
						break;
				}
			} );
			_singleLayerContextMenu.show( x, y );
		}
		
		
		private var _downComplex:TemplateTableItem = null;
		private function onTemplatesMouseDown( e:MouseEvent ): void
		{
			_downComplex = FindTableItem( e ) as TemplateTableItem
		}
		private function onTemplatesMouseUp( e:MouseEvent ): void
		{
			_downComplex = null;
		}
		private function onTemplatesMouseMove( e:MouseEvent ): void
		{
			if ( _downComplex == null )
			{
				return;
			}
			
			if ( _downComplex.template._singleResource == null )
			{
				PopUp( "Specify template's graphics first.", POP_UP_ERROR );
			}
			else if ( _downComplex.template._layer == null )
			{
				PopUp( "Specify template's layer first.", POP_UP_ERROR );
			}
			else
			{
				StartDrag( e, _downComplex.template, Global.DRAG_FORMAT_COMPLEX_TEMPLATE, _downComplex.template._singleResource.FindClass( _project ) );
			}
			
			//to ignore other mouse moves:
			_downComplex = null;
		}
		
		
		private var _downCompound:CompoundTableItem = null;
		private function onCompoundsMouseDown( e:MouseEvent ): void
		{
			_downCompound = FindTableItem( e ) as CompoundTableItem;
		}
		private function onCompoundsMouseUp( e:MouseEvent ): void
		{
			_downCompound = null;
		}
		private function onCompoundsMouseMove( e:MouseEvent ): void
		{
			if ( _downCompound == null )
			{
				return;
			}
			
			if ( _downCompound.compound._consisting.length <= 0 )
			{
				PopUp( "Specify at least one complex within chosen compound first.", POP_UP_ERROR );
			}
			else
			{
				StartDrag( e, _downCompound.compound, Global.DRAG_FORMAT_COMPOUND_TEMPLATE, _downCompound.compound._consisting[ 0 ]._complex._singleResource.FindClass( _project ) );
			}
			
			//to ignore other mouse moves:
			_downCompound = null;
		}
		
		
		private var _downUnitListItem:UnitDesc = null;
		private function onUnitsMouseDown( e:MouseEvent ): void
		{
			var unitListItem:UnitListItem = FindListItem( e, UnitListItem );
			if ( unitListItem != null )
			{
				_downUnitListItem = unitListItem.unit;
			}
		}
		private function onUnitsMouseUp( e:MouseEvent ): void
		{
			_downUnitListItem = null;
		}
		private function onUnitsMouseMove( e:MouseEvent ): void
		{
			if ( _downUnitListItem == null )
			{
				return;
			}
			
			StartDrag( e, _downUnitListItem, Global.DRAG_FORMAG_UNIT_DESC, _downUnitListItem._singleResource.FindClass( _project ) );
			
			//to ignore other mouse moves:
			_downUnitListItem = null;
		}
		
		
		public var _unitsContextMenu:Menu = null;
		private function onUnitsContextMenu( e:MouseEvent ): void
		{
			var thisOne:Main = this;
			
			if ( _unitsContextMenu != null )
			{
				_unitsContextMenu.hide();
				_unitsContextMenu = null;
			}
			
			var unitListItem:UnitListItem = FindListItem( e, UnitListItem ) as UnitListItem;
			if ( unitListItem == null )
			{
				return;
			}
			
			var menuData:Array =[ { label: "Edit...", id: "edit", unit: unitListItem.unit } ];
			
			_unitsContextMenu = Menu.createMenu( null, menuData );
			_unitsContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "edit":
						var editingUnitWindow:EditingUnitWindow = PopUpManager.createPopUp( thisOne, EditingUnitWindow, false ) as EditingUnitWindow;
						editingUnitWindow.Init( _project, menuEvent.item.unit, thisOne );
						PopUpManager.centerPopUp( editingUnitWindow );
						break;
				}
			} );
			_unitsContextMenu.show( e.stageX, e.stageY );
		}
		
		
		public static function StartDrag( e : MouseEvent, data : Object, format : String, imageClass : Class ) : void
		{
			var uiComponent : UIComponent = Utils.FindParentByType( e.target as DisplayObject, UIComponent ) as UIComponent;
			if ( uiComponent == null )
			{
				Cc.error( "E: Main.StartDrag(): failed to accomplish drag/drop quest." );
			}
			else
			{
				var dragSource : DragSource = new DragSource;
				dragSource.addData( data, format );
				
				var proxy:mx.controls.Image = new mx.controls.Image;
				proxy.source = imageClass;
				
				var viewToGlobal:Point = ( e.target as DisplayObject ).localToGlobal( new Point );
				var targetToGlobal:Point = uiComponent.localToGlobal( new Point );
				
				DragManager.doDrag( uiComponent, dragSource, e, proxy, targetToGlobal.x - viewToGlobal.x, targetToGlobal.y - viewToGlobal.y );
			}
		}
		
		
		
		public static const POP_UP_INFO : int = 1;
		public static const POP_UP_WARNING : int = 2;
		public static const POP_UP_ERROR : int = 3;
		[ Embed( source = "info_icon.png" ) ]
		private var _infoIconClass : Class;
		[ Embed( source = "warning_icon.png" ) ]
		private var _warningIconClass : Class;
		[ Embed( source = "error_icon.png" ) ]
		private var _errorIconClass : Class;
		
		public function PopUp( message : String, type : int ) : void
		{
			var iconClass : Class = _infoIconClass;
			var title : String = "Info";
			switch ( type )
			{
				case POP_UP_WARNING:
					iconClass = _warningIconClass;
					title = "Warning";
					break;
				
				case POP_UP_ERROR:
					iconClass = _errorIconClass;
					title = "Error";
					break;
			}
			Alert.show( message, title, Alert.OK, null, null, iconClass );
		}
		
		public function onMenuItem( e : MenuEvent ) : void
		{
			var thisOne : Main = this;
			
			switch ( e.item.@id.toString() )
			{
				/// FILE:
				
				case "open_project":
					if ( _changeMade )
					{
						PopUp( "Some modifications was already made. Restart the editor to be able to load a project file.", POP_UP_ERROR );
						break;
					}
					
					var openingProjectFile : File = new File;
					
					openingProjectFile.addEventListener( Event.SELECT, function( e:Event ): void
					{
						projectPath = openingProjectFile.nativePath;
						
						var openingProjectFileStream : FileStream = new FileStream;
						var ok : Boolean = true;
						try
						{
							openingProjectFileStream.open( openingProjectFile, FileMode.READ );
						}
						catch ( e : Error )
						{
							PopUp( "Project file opening failed with error: " + e.message, POP_UP_ERROR );
							ok = false;
						}
						
						if ( ok )
						{
							_changeMade = true;
							
							var bytes : ByteArray = new ByteArray;
							openingProjectFileStream.readBytes( bytes );
							
							//let's try clean-up currently existing instances a little:
							_isometry.Unload();
							//TODO
							///...
							//well, not we got rid of it using _changeMade variable...
							
							_project.Accept( bytes, function( errorText : String ) : void
							{
								if ( errorText == null )
								{
									PopUp( "Project successfully loaded.", POP_UP_INFO );
								}
								else
								{
									PopUp( "Project file reading failed: wrong format: \"" + errorText + "\".", POP_UP_ERROR );
								}
							} );
						}
						
						openingProjectFileStream.close();
					} );
					openingProjectFile.addEventListener( IOErrorEvent.IO_ERROR, function( ioErrorEvent : IOErrorEvent ) : void
					{
						PopUp( "Opening failed with error: " + ioErrorEvent.text, POP_UP_ERROR );
					} );
					openingProjectFile.addEventListener( SecurityErrorEvent.SECURITY_ERROR, function( securityErrorEvent : SecurityErrorEvent ): void
					{
						PopUp( "Opening failed with error: " + securityErrorEvent.text, POP_UP_ERROR );
					} );
					
					openingProjectFile.browse();
					break;
				
				case "save_project":
					if ( _projectPath == null )
					{
						PopUp( "Program error: no path known.", POP_UP_ERROR );
					}
					else
					{
						SaveProject( _projectPath );
					}
					break;
				
				case "save_project_as":
					var savingAsFile:File = new File;
					savingAsFile.addEventListener( Event.SELECT, function( ... args ): void
					{
						projectPath = savingAsFile.nativePath;
						
						SaveProject( _projectPath );
					} );
					savingAsFile.browse();
					break;
				
				case "generate_sources":
					GenerateSources();
					break;
				
				
				///PROJECT:
				
				case "project_properties":
					var editingProjectWindow : EditingProjectWindow = PopUpManager.createPopUp( thisOne, EditingProjectWindow, false ) as EditingProjectWindow;
					editingProjectWindow.Init( _project );
					PopUpManager.centerPopUp( editingProjectWindow );
					break;
				
				
				///PREFERENCES:
				
				case "preferences_edit":
					var editingPreferencesWindow : EditingPreferencesWindow = PopUpManager.createPopUp( thisOne, EditingPreferencesWindow, false ) as EditingPreferencesWindow;
					editingPreferencesWindow.Init( _project );
					PopUpManager.centerPopUp( editingPreferencesWindow );
					break;
				
				
				///HELP:
				
				case "about":
					PopUp( "Isometric editor as part of \"Blisc\" engine. If you have any suggestions or issues please contact SlavMFM@gmail.com", POP_UP_INFO );
					break;
			}
		}
		
		private function GenerateSources() : void
		{
			if ( _project._data._sourcesDirectory.length <= 0 )
			{
				PopUp( "Specify sources folder within project editing window first.", POP_UP_ERROR );
				return;
			}
			
			var wasError : Boolean = false;
			
			//only this way (creating new File object from applicationDirectory.nativePath) allows to navigate from application directory somewhere (otherwise call to createDirectory() thrown SecurityError exception):
			var directory : File = new File ( File.applicationDirectory.nativePath );
			directory = directory.resolvePath( _project._data._sourcesDirectory );
			directory.createDirectory();
			
			var resourcesFile : File = directory.resolvePath( "Resources.as" );
			var rs : FileStream = new FileStream;
			rs.open( resourcesFile, FileMode.WRITE );
			
			var binaryFile : File = directory.resolvePath( "resources_data.brd" );
			var bs : FileStream = new FileStream;
			bs.open( binaryFile, FileMode.WRITE );
			
			var animationsFile : File = directory.resolvePath( "animations_data.bad" );
			var ns : FileStream = new FileStream;
			ns.open( animationsFile, FileMode.WRITE );
			
			var mapsFile : File = directory.resolvePath( "maps.bmd" );
			var ms : FileStream = new FileStream;
			ms.open( mapsFile, FileMode.WRITE );
			
			//counting amount of units to predefine array length:
			var unitsCount : int = 0;
			for each ( var countingUnitsResource : Resource in _project._data._resources )
			{
				unitsCount += countingUnitsResource._units.length;
			}
			
			rs.writeUTFBytes( "///@cond\n" );
			rs.writeUTFBytes( "package\n" );
			rs.writeUTFBytes( "{\n" );
			rs.writeUTFBytes( "	import com.junkbyte.console.Cc;\n" );
			rs.writeUTFBytes( "	import flash.geom.Point;\n" );
			rs.writeUTFBytes( "	import flash.display.DisplayObject;\n" );
			rs.writeUTFBytes( "	import flash.display.Loader;\n" );
			rs.writeUTFBytes( "	import flash.display.LoaderInfo;\n" );
			rs.writeUTFBytes( "	import flash.display.MovieClip;\n" );
			rs.writeUTFBytes( "	import flash.utils.Timer;\n" );
			rs.writeUTFBytes( "	import flash.events.TimerEvent;\n" );
			rs.writeUTFBytes( "	import blisc.core.BliscAnimation;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscLayerTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscRegion;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscObjectTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscMapTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscComplexTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscRegionWithinComplex;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscCompoundTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscComplexWithinCompoundTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscUnitTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscAnimationTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscObjectInstanceTemplate;\n" );
			rs.writeUTFBytes( "	import blisc.templates.BliscUnitView;\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	///@endcond\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	public class Resources\n" );
			rs.writeUTFBytes( "	{\n" );
			//global properties:
			rs.writeUTFBytes( "		/** Distance from tile's center to east side.*/\n" );
			rs.writeUTFBytes( "		public static const TILE_SIZE : Number = " + _project._data._tileSize.toString() + ";\n" );
			rs.writeUTFBytes( "		/** Distance from tile's north side to east.*/\n" );
			rs.writeUTFBytes( "		public static const TILE_SIDE : Number = " + _project.side.toString() + ";\n" );
			rs.writeUTFBytes( "		\n" );
			//trough alpha:
			rs.writeUTFBytes( "		/** Which alpha value must be set to overlapping objects when deeper one is chosen. 0 - fully transparent, 255 - fully opaque.*/\n" );
			rs.writeUTFBytes( "		public static const THROUGH_ALPHA : int = " + _project._data._throughAlpha.toString() + ";\n" );
			rs.writeUTFBytes( "		\n" );
			//slipping value:
			rs.writeUTFBytes( "		/** Maximum amount of adjacent neighbour tiles unit can slip through when walking over tile's angle (north, east, south, west).*/\n" );
			rs.writeUTFBytes( "		public static const SLIPPING_VALUE : int = " + _project._data._slippingValue.toString() + ";\n" );
			rs.writeUTFBytes( "		\n" );
			//onReady():
			rs.writeUTFBytes( "		/** Will be called when everything is done.*/\n" );
			rs.writeUTFBytes( "		private var _onReady : Function;\n" );
			//animations cache:
			rs.writeUTFBytes( "		/** Single instance for each template.*/\n" );
			rs.writeUTFBytes( "		public var _animationsCache : Vector.< CachedAnimation > = new Vector.< CachedAnimation >;\n" );
			//layers:
			rs.writeUTFBytes( "		/** In order of displaying.*/\n" );
			rs.writeUTFBytes( "		public var _layers : Vector.< BliscLayerTemplate > = new Vector.< BliscLayerTemplate >( " + _project._data._layers.length + ", true );\n" );
			rs.writeUTFBytes( "		\n" );
			//regions:
			rs.writeUTFBytes( "		public var _regions : Vector.< BliscRegion > = new Vector.< BliscRegion >( " + _project._data._regions.length + ", true );\n" );
			rs.writeUTFBytes( "		\n" );
			//complexes and compounds:
			rs.writeUTFBytes( "		public var _objects : Vector.< BliscObjectTemplate > = new Vector.< BliscObjectTemplate >( " + _project._data._objects.length + ", true );\n" );
			rs.writeUTFBytes( "		\n" );
			//units:
			rs.writeUTFBytes( "		public var _units : Vector.< BliscUnitTemplate >;\n" );
			rs.writeUTFBytes( "		\n" );
			//maps:
			rs.writeUTFBytes( "		public var _maps : Vector.< BliscMapTemplate > = new Vector.< BliscMapTemplate >;\n" );
			rs.writeUTFBytes( "		\n" );
			//animation properties:
			rs.writeUTFBytes( "		public var _animationTemplates : Vector.< BliscAnimationTemplate > = new Vector.< BliscAnimationTemplate >;\n" );
			rs.writeUTFBytes( "		\n" );
			//embedding resources:
			for ( var declaringIndex : int = 0; declaringIndex < _project._data._resources.length; ++declaringIndex )
			{
				var declaringResource : Resource = _project._data._resources[ declaringIndex ];
				var declaringResourceFile : File = new File( File.applicationDirectory.nativePath );
				declaringResourceFile = declaringResourceFile.resolvePath( declaringResource._path );
				
				var embeddingPath : String = directory.getRelativePath( declaringResourceFile, true );
				rs.writeUTFBytes( "		[ Embed( source = \"" + embeddingPath + "\" ) ]\n" );
				rs.writeUTFBytes( "		private var _" + declaringIndex.toString() + " : Class;\n" );
				rs.writeUTFBytes( "		\n" );
			}
			rs.writeUTFBytes( "		\n" );
			//array holding all embedded resources:
			rs.writeUTFBytes( "		private var _allEmbeddedResources : Vector.< EmbeddedResource > = new Vector.< EmbeddedResource >;\n" );
			rs.writeUTFBytes( "		\n" );
			//loaded resources counter:
			rs.writeUTFBytes( "		private var _leftResources : int = " + _project._data._resources.length.toString() + ";\n" );
			rs.writeUTFBytes( "		\n" );
			rs.writeUTFBytes( "		\n" );
			//constructor:
			rs.writeUTFBytes( "		/** .\n" );
			rs.writeUTFBytes( "		\\param onReady function() : void Called when all resources are loaded.\n" );
			rs.writeUTFBytes( "		*/\n" );
			rs.writeUTFBytes( "		public function Resources( onReady : Function )\n" );
			rs.writeUTFBytes( "		{\n" );
			rs.writeUTFBytes( "			_onReady = onReady;\n" );
			rs.writeUTFBytes( "			\n" );
			//resource loading function:
			rs.writeUTFBytes( "			function OnResourceLoaded() : void\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				--_leftResources;\n" );
			rs.writeUTFBytes( "				if ( _leftResources <= 0 )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					InitTemplates();\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			\n" );
			for ( var instantiatingIndex : int = 0; instantiatingIndex < _project._data._resources.length; ++instantiatingIndex )
			{
				rs.writeUTFBytes( "			_allEmbeddedResources.push( new EmbeddedResource( \"" + _project._data._resources[ instantiatingIndex ]._path + "\", _" + instantiatingIndex.toString() + ", OnResourceLoaded ) );\n" );
			}
			rs.writeUTFBytes( "		}\n" );
			rs.writeUTFBytes( "		\n" );
			
			//graphics resolving function:
			rs.writeUTFBytes( "		/** Returns any graphical item with specified name within specified SWF or any first (within cache or SWF) if editorsPath is null.\n" );
			rs.writeUTFBytes( "		\\param name MovieClip's name within SWF.\n" );
			rs.writeUTFBytes( "		\\param editorsPath Within which SWF to look or within any if null.*/\n" );
			rs.writeUTFBytes( "		public function ResolveGraphics( name : String, editorsPath : String = null, startingFrame : int = 0, endingFrame : int = int.MAX_VALUE ) : BliscAnimation\n" );
			rs.writeUTFBytes( "		{\n" );
			rs.writeUTFBytes( "			//trying to find within cache:\n" );
			rs.writeUTFBytes( "			for each ( var cachedAnimation : CachedAnimation in _animationsCache )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				if ( name != cachedAnimation._animation._name\n" );
			rs.writeUTFBytes( "					|| cachedAnimation._startingFrame != startingFrame\n" );
			rs.writeUTFBytes( "					|| cachedAnimation._endingFrame != endingFrame\n" );
			rs.writeUTFBytes( "					|| ( editorsPath != null && editorsPath != cachedAnimation._editorsPath )\n" );
			rs.writeUTFBytes( "				)\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					continue;\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				return cachedAnimation._animation;\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			\n" );
			rs.writeUTFBytes( "			for each ( var embeddedResource : EmbeddedResource in _allEmbeddedResources )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				if ( editorsPath != null && embeddedResource._editorsPath != editorsPath )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					continue;\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				var found : MovieClip;\n" );
			rs.writeUTFBytes( "				try\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					found = new ( embeddedResource._applicationDomain.getDefinition( name ) as Class ) as MovieClip;\n" );
			rs.writeUTFBytes( "				}\n" )
			rs.writeUTFBytes( "				catch( e : Error )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					if ( editorsPath != null )\n" );
			rs.writeUTFBytes( "					{\n" );
			rs.writeUTFBytes( "						Cc.error( \"E: Resources.ResolveGraphics(): resource \\\"\" + name + \"\\\" within \\\"\" + editorsPath + \"\\\". Returning null.\" );\n" );
			rs.writeUTFBytes( "						return null;\n" );
			rs.writeUTFBytes( "					}\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				if ( found == null )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					if ( editorsPath == null )\n" );
			rs.writeUTFBytes( "					{\n" );
			rs.writeUTFBytes( "						continue;\n" );
			rs.writeUTFBytes( "					}\n" );
			rs.writeUTFBytes( "					else\n" );
			rs.writeUTFBytes( "					{\n" );
			rs.writeUTFBytes( "						Cc.error( \"E: Resources.ResolveGraphics(): resource \\\"\" + name + \"\\\" within \\\"\" + editorsPath + \"\\\" is NOT of type MovieClip. Returning null.\" );\n" );
			rs.writeUTFBytes( "						return null;\n" );
			rs.writeUTFBytes( "					}\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				var resolved : BliscAnimation = null;\n" );
			rs.writeUTFBytes( "				//looking for animation's predefined display sequence:\n" );
			rs.writeUTFBytes( "				for each ( var animationTemplate : BliscAnimationTemplate in _animationTemplates )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					if ( animationTemplate._editorsPath == embeddedResource._editorsPath && animationTemplate._name == name )\n" );
			rs.writeUTFBytes( "					{\n" );
			rs.writeUTFBytes( "						resolved = BliscAnimation.FromSequence( found, embeddedResource._frameRate, animationTemplate._frames, startingFrame, endingFrame, name );\n" );
			rs.writeUTFBytes( "						break;\n" );
			rs.writeUTFBytes( "					}\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				//wasn't found within predefined templates:\n" );
			rs.writeUTFBytes( "				if ( resolved == null )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					resolved = BliscAnimation.FromMovieClip( found, embeddedResource._frameRate, name, startingFrame, endingFrame );\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				_animationsCache.push( new CachedAnimation( resolved, embeddedResource._editorsPath, startingFrame, endingFrame ) );\n" );
			rs.writeUTFBytes( "				return resolved;\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			\n" );
			rs.writeUTFBytes( "			if ( editorsPath == null )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				Cc.error( \"E: Resources.ResolveGraphics(): resource \\\"\" + name + \"\\\" was NOT found. Returning null.\" );\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			else\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				Cc.error( \"E: Resources.ResolveGraphics(): resource \\\"\" + name + \"\\\" within SWF \\\"\" + editorsPath + \"\\\" was NOT found. Returning null.\" );\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			return null;\n" );
			rs.writeUTFBytes( "		}\n" );
			rs.writeUTFBytes( "		\n" );
			
			//class resolving function:
			rs.writeUTFBytes( "		/** Searches class with specified name within any resource returning first occurence.*/\n" );
			rs.writeUTFBytes( "		public function ResolveClass( name : String ) : Class\n" );
			rs.writeUTFBytes( "		{\n" );
			rs.writeUTFBytes( "			for each ( var embeddedResource : EmbeddedResource in _allEmbeddedResources )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				if ( embeddedResource._applicationDomain.hasDefinition( name ) )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					return embeddedResource._applicationDomain.getDefinition( name ) as Class;\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			\n" );
			rs.writeUTFBytes( "			return null;\n" );
			rs.writeUTFBytes( "		}\n" );
			
			//custom graphics resolving function:
			rs.writeUTFBytes( "		/** Doesn't concern caching.*/\n" );
			rs.writeUTFBytes( "		public function ResolveCustomGraphics( name : String ) : DisplayObject\n" );
			rs.writeUTFBytes( "		{\n" );
			rs.writeUTFBytes( "			var resolvedClass : Class = ResolveClass( name );\n" );
			rs.writeUTFBytes( "			if ( resolvedClass == null )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				Cc.error( \"E: Resources.ResolveCustomGraphics(): resource \\\"\" + name + \"\\\" was NOT found. Returning null.\" );\n" );
			rs.writeUTFBytes( "				return null;\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "			else\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				var found : DisplayObject = new resolvedClass as DisplayObject;\n" );
			rs.writeUTFBytes( "				if ( found == null )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					Cc.error( \"E: Resources.ResolveCustomGraphics(): resource \\\"\" + name + \"\\\" is NOT of DisplayObject type. Returning null.\" );\n" );
			rs.writeUTFBytes( "					return null;\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				return found;\n" );
			rs.writeUTFBytes( "			}\n" );
			rs.writeUTFBytes( "		}\n" );
			rs.writeUTFBytes( "		\n" );
			
			//templates initing function:
			rs.writeUTFBytes( "		private function InitTemplates() : void\n" );
			rs.writeUTFBytes( "		{\n" );
			
			//layers:
			for ( var layerIndex : int = 0; layerIndex < _project._data._layers.length; ++layerIndex )
			{
				rs.writeUTFBytes( "			_layers[ " + layerIndex + " ] = new BliscLayerTemplate( \"" + _project._data._layers[ layerIndex ]._name + "\", " + _project._data._layers[ layerIndex ]._units.toString() + ", " + _project._data._layers[ layerIndex ]._selectable.toString() + " );\n" );
			}
			rs.writeUTFBytes( "			\n" );
			
			//regions:
			for ( var regionIndex : int = 0; regionIndex < _project._data._regions.length; ++regionIndex )
			{
				rs.writeUTFBytes( "			_regions[ " + regionIndex + " ] = new BliscRegion( \"" + _project._data._regions[ regionIndex ]._name + "\", " + _project._data._regions[ regionIndex ]._type.toString() + ", 0x" + _project._data._regions[ regionIndex ]._color.toString( 16 ) + " );\n" );
			}
			rs.writeUTFBytes( "			\n" );
			
			var animationDescs : Vector.< AnimationDesc > = new Vector.< AnimationDesc >;
			function ResolveAnimationId(
				name : String,
				editorsPath : String,
				startingFrame : int = 1,
				endingFrame : int = int.MAX_VALUE
			) : int
			{
				for each ( var lookingAnimationDesc : AnimationDesc in animationDescs )
				{
					if (
						lookingAnimationDesc._name == name &&
						lookingAnimationDesc._editorsPath == editorsPath &&
						lookingAnimationDesc._startingFrame == startingFrame &&
						lookingAnimationDesc._endingFrame == endingFrame
					)
					{
						return lookingAnimationDesc._id;
					}
				}
				
				var newAnimationDesc : AnimationDesc = new AnimationDesc(
					animationDescs.length + 1,
					name,
					editorsPath,
					startingFrame,
					endingFrame
				);
				
				animationDescs.push( newAnimationDesc );
				
				return newAnimationDesc._id;
			};
			
			//writing units into binary file:
			//units descs amount:
			bs.writeInt( unitsCount );
			//units itself:
			for each ( var resourceWithUnits : Resource in _project._data._resources )
			{
				for each ( var unitDesc : UnitDesc in resourceWithUnits._units )
				{
					var unitProperties : UnitProperties = _project.FindUnitProperties( unitDesc, true );
					
					//surfaces:
					//surfaces amount:
					bs.writeInt( unitProperties._surfaces.length );
					//surfaces itself:
					for ( var surfaceWithinUnitIndex : int = 0; surfaceWithinUnitIndex < unitProperties._surfaces.length; ++surfaceWithinUnitIndex )
					{
						var surfaceWithinUnit : Region = unitProperties._surfaces[ surfaceWithinUnitIndex ];
						
						bs.writeInt( _project._data._regions.indexOf( surfaceWithinUnit ) );
					}
					
					//unit views:
					//views amount:
					bs.writeInt( unitDesc._template._views.length );
					//views itself:
					for ( var unitViewIndex : int = 0; unitViewIndex < unitDesc._template._views.length; ++unitViewIndex )
					{
						var unitView : BliscUnitView = unitDesc._template._views[ unitViewIndex ];
						var unitViewOrientation : UnitOrientation = unitDesc._orientations[ unitViewIndex ];
						
						bs.writeInt( unitViewOrientation._orientation );
						bs.writeInt( ResolveAnimationId(
							unitDesc._singleResource._name,
							unitDesc._singleResource._resourcePath,
							unitViewOrientation._startingFrame,
							unitViewOrientation._endingFrame
						) );
					}
					
					//refused redirections:
					bs.writeInt( unitProperties._refusedDirections.length );
					for ( var refusedDirectionIndex : int = 0; refusedDirectionIndex < unitProperties._refusedDirections.length; ++refusedDirectionIndex )
					{
						bs.writeInt( unitProperties._refusedDirections[ refusedDirectionIndex ] );
					}
					
					//unit name:
					bs.writeUTFBytes( unitDesc._template._name );
					
					//unit animation name:
					bs.writeUTFBytes( unitDesc._template._animation );
				}
			}
			
			//units reading code:
			rs.writeUTFBytes( "			//reading units:\n" );
			rs.writeUTFBytes( "			const unitsCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "			_units = new Vector.< BliscUnitTemplate >;\n" );
			rs.writeUTFBytes( "			for ( var readingUnitIndex : int = 0; readingUnitIndex < unitsCount; ++readingUnitIndex )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				//surfaces:\n" );
			rs.writeUTFBytes( "				const surfacesCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				var surfaces : Vector.< BliscRegion > = new Vector.< BliscRegion >( surfacesCount, true );\n" );
			rs.writeUTFBytes( "				for ( var surfaceIndex : int = 0; surfaceIndex < surfacesCount; ++surfaceIndex )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					surfaces[ surfaceIndex ] = _regions[ bs.readInt() ];\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				//views:\n" );
			rs.writeUTFBytes( "				const viewsCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				var views : Vector.< BliscUnitView > = new Vector.< BliscUnitView >( viewsCount, true );\n" );
			rs.writeUTFBytes( "				for ( var viewIndex : int = 0; viewIndex < viewsCount; ++viewIndex )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					views[ viewIndex ] = new BliscUnitView( bs.readInt(), bs.readInt() );\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				//refused redirections:\n" );
			rs.writeUTFBytes( "				const refusedRedirectionsCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				var refusedRedirections : Vector.< int > = new Vector.< int >( refusedRedirectionsCount, true );\n" );
			rs.writeUTFBytes( "				for ( var refusedRedirectionIndex : int = 0; refusedRedirectionIndex < refusedRedirectionsCount; ++refusedRedirectionIndex )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					refusedRedirections[ refusedRedirectionIndex ] = bs.readInt();\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				_units[ readingUnitIndex ] = new BliscUnitTemplate( bs.readUTFBytes(), bs.readUTFBytes(), surfaces, views, refusedRedirections );\n" );
			rs.writeUTFBytes( "			}\n" );
			
			//counting templates for future steps:
			var complexesCount : int = 0;
			var compoundsCount : int = 0;
			for each ( var object : ObjectTemplate in _project._data._objects )
			{
				if ( object is ComplexTemplate )
				{
					++complexesCount;
				}
				else if ( object is CompoundTemplate )
				{
					++compoundsCount;
				}
			}
			
			//writing objects (complexes and compounds) templates into binary file:
			//complexes data:
			var xd : ByteArray = new ByteArray;
			xd.writeInt( complexesCount );
			var complexesInited : int = 0;
			//compounds data:
			var nd : ByteArray = new ByteArray;
			nd.writeInt( compoundsCount );
			//writing both but into different streams so streams will be written instead later:
			for ( var objectIndex : int = 0; objectIndex < _project._data._objects.length; ++objectIndex )
			{
				var complex : ComplexTemplate = _project._data._objects[ objectIndex ] as ComplexTemplate;
				var compound : CompoundTemplate = _project._data._objects[ objectIndex ] as CompoundTemplate;
				
				//if still complexes initing process:
				if ( complexesInited < complexesCount )
				{
					if ( complex == null )
					{
						continue;
					}
				}
				else
				{
					if ( compound == null )
					{
						continue;
					}
				}
				
				if ( complex != null )
				{
					xd.writeInt( objectIndex );
					
					//regions:
					xd.writeInt( complex._regions.length );
					for ( var regionWithinComplexIndex : int = 0; regionWithinComplexIndex < complex._regions.length; ++regionWithinComplexIndex )
					{
						var regionWithinComplex : RegionWithinComplex = complex._regions[ regionWithinComplexIndex ];
						
						//tiles which current region occupies:
						xd.writeInt( regionWithinComplex._tiles.length );
						for ( var tileWithinRegionIndex : int = 0; tileWithinRegionIndex < regionWithinComplex._tiles.length; ++tileWithinRegionIndex )
						{
							xd.writeFloat( regionWithinComplex._tiles[ tileWithinRegionIndex ].x );
							xd.writeFloat( regionWithinComplex._tiles[ tileWithinRegionIndex ].y );
						}
						
						//region index:
						xd.writeInt( _project._data._regions.indexOf( regionWithinComplex._region ) );
					}
					
					xd.writeUTFBytes( complex._name );
					
					//animation index:
					xd.writeInt( ResolveAnimationId( 
						complex._singleResource._name,
						complex._singleResource._resourcePath
					) );
					
					xd.writeFloat( complex._disp.x );
					xd.writeFloat( complex._disp.y );
					
					xd.writeFloat( complex._center.x );
					xd.writeFloat( complex._center.y );
					
					xd.writeUTFBytes( complex._layer._name );
					
					xd.writeBoolean( complex._interactive );
					
					++complexesInited;
				}
				else if ( compound != null )
				{
					nd.writeInt( objectIndex );
					
					nd.writeInt( compound._consisting.length );
					for ( var compoundConsistingIndex : int = 0; compoundConsistingIndex < compound._consisting.length; ++compoundConsistingIndex )
					{
						var compoundConsisting : ComplexWithinCompound = compound._consisting[ compoundConsistingIndex ];
						
						nd.writeInt( _project._data._objects.indexOf( compoundConsisting._complex ) );
						
						nd.writeFloat( compoundConsisting._tileDispX );
						nd.writeFloat( compoundConsisting._tileDispY );
					}
					
					nd.writeUTFBytes( compound._name );
				}
				else
				{
					PopUp( "Undefined object type", POP_UP_ERROR );
				}
			}
			//writing rendered data in an order it will be read:
			bs.writeBytes( xd );
			bs.writeBytes( nd );
			
			//complexes reading code:
			rs.writeUTFBytes( "			//reading complexes:\n" );
			rs.writeUTFBytes( "			const complexesCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "			for ( var complexIndex : int = 0; complexIndex < complexesCount; ++complexIndex )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				const complexArrayIndex : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				//regions:\n" );
			rs.writeUTFBytes( "				const regionsCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				var regions : Vector.< BliscRegionWithinComplex > = new Vector.< BliscRegionWithinComplex >( regionsCount, true );\n" );
			rs.writeUTFBytes( "				for ( var regionIndex : int = 0; regionIndex < regionsCount; ++regionIndex )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					const tilesCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "					var tiles : Vector.< Point > = new Vector.< Point >( tilesCount, true );\n" );
			rs.writeUTFBytes( "					for ( var tileIndex : int = 0; tileIndex < tilesCount; ++tileIndex )\n" );
			rs.writeUTFBytes( "					{\n" );
			rs.writeUTFBytes( "						tiles[ tileIndex ] = new Point( bs.readFloat(), bs.readFloat() );\n" );
			rs.writeUTFBytes( "					}\n" );
			rs.writeUTFBytes( "					\n" );
			rs.writeUTFBytes( "					regions[ regionIndex ] = new BliscRegionWithinComplex( _regions[ bs.readInt() ], tiles );\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				_objects[ complexArrayIndex ] = new BliscComplexTemplate( bs.readUTFBytes(), bs.readInt(), null, new Point( bs.readFloat(), bs.readFloat() ), new Point( bs.readFloat(), bs.readFloat() ), bs.readUTFBytes(), regions, bs.readBoolean );\n" );
			rs.writeUTFBytes( "			}\n" );
			
			//compounds reading code:
			rs.writeUTFBytes( "			\n" );
			rs.writeUTFBytes( "			//reading compounds:\n" );
			rs.writeUTFBytes( "			const compoundsCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "			for ( var compoundIndex : int = 0; compoundIndex < compoundsCount; ++compoundIndex )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				const compoundArrayIndex : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				//consisting complexes:\n" );
			rs.writeUTFBytes( "				const consistingComplexesCount : int = bs.readInt();\n" );
			rs.writeUTFBytes( "				var consistingComplexes : Vector.< BliscComplexWithinCompoundTemplate > = new Vector.< BliscComplexWithinCompoundTemplate >( consistingComplexesCount, true );\n" );
			rs.writeUTFBytes( "				for ( var consistingComplexIndex : int = 0; consistingComplexIndex < consistingComplexesCount; ++consistingComplexIndex )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					consistingComplexes[ consistingComplexIndex ] = new BliscComplexWithinCompoundTemplate( _objects[ bs.readInt() ], new Point( bs.readFloat(), bs.readFloat() ) );\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				_objects[ compoundArrayIndex ] = new BliscCompoundTemplate( bs.readUTFBytes(), consistingComplexes );\n" );
			rs.writeUTFBytes( "			}\n" );
			
			//maps:
			ms.writeInt( _project._data._maps.length );
			for ( var mapIndex : int = 0; mapIndex < _project._data._maps.length; ++mapIndex )
			{
				var map : Map = _project._data._maps[ mapIndex ];
				
				//instances:
				ms.writeInt( map._instances.length );
				for ( var instanceIndex : int = 0; instanceIndex < map._instances.length; ++instanceIndex )
				{
					var objectInstance : ObjectInstance = map._instances[ instanceIndex ];
					
					const indexWithinData : int = _project._data._objects.indexOf( objectInstance._template );
					if ( indexWithinData < 0 )
					{
						var errorString : String = "\"" + objectInstance._template._name + "\" at tile " + objectInstance._tileCoords.x.toString() + " | " + objectInstance._tileCoords.y.toString() + " was NOT found within data.";
						Cc.error( "E: Main.GenerateSources(): " + errorString );
						if ( wasError == false )
						{
							wasError = true;
							PopUp( errorString, POP_UP_ERROR );
							return;
						}
					}
					
					ms.writeInt( indexWithinData );
					
					ms.writeFloat( objectInstance._tileCoords.x );
					ms.writeFloat( objectInstance._tileCoords.y );
				}
				
				ms.writeUTFBytes( map._name );
				
				ms.writeInt( map._right );
				ms.writeInt( map._down );
			}
			
			//maps reading code:
			rs.writeUTFBytes( "			\n" );
			rs.writeUTFBytes( "			const mapsCount : int = ms.readInt();\n" );
			rs.writeUTFBytes( "			_maps = new Vector.< BliscMapTemplate > = new Vector.< BliscMapTemplate >( mapsCount, true );\n" );
			rs.writeUTFBytes( "			for ( var mapIndex = 0; mapIndex < mapsCount; ++mapIndex )\n" );
			rs.writeUTFBytes( "			{\n" );
			rs.writeUTFBytes( "				//instances:\n" );
			rs.writeUTFBytes( "				const instancesCount : int = ms.readInt();\n" );
			rs.writeUTFBytes( "				var instances : Vector.< BliscObjectInstanceTemplate > = new Vector.< BliscObjectInstanceTemplate >( instancesCount, true );\n" );
			rs.writeUTFBytes( "				for ( var instanceIndex : int = 0; instanceIndex < instancesCount; ++instanceIndex )\n" );
			rs.writeUTFBytes( "				{\n" );
			rs.writeUTFBytes( "					instances[ instanceIndex ] = new BliscObjectInstanceTemplate( _objects[ ms.readInt() ], ms.readFloat(), ms.readFloat() );\n" );
			rs.writeUTFBytes( "				}\n" );
			rs.writeUTFBytes( "				\n" );
			rs.writeUTFBytes( "				_maps[ mapIndex ] = new BliscMapTemplate( ms.readUTFBytes(), ms.readInt(), ms.readInt(), instances );\n" );
			rs.writeUTFBytes( "			}\n" );
			
			rs.writeUTFBytes( "		}\n" );
			
			rs.writeUTFBytes( "	}\n" );
			
			rs.writeUTFBytes( "}\n" );
			
			//private classes:
			rs.writeUTFBytes( "\n" );
			rs.writeUTFBytes( "import blisc.core.BliscAnimation;\n" );
			rs.writeUTFBytes( "import mx.core.MovieClipAsset;\n" );
			rs.writeUTFBytes( "import flash.system.ApplicationDomain;\n" );
			rs.writeUTFBytes( "import flash.events.Event;\n" );
			rs.writeUTFBytes( "import flash.display.LoaderInfo;\n" );
			rs.writeUTFBytes( "import flash.display.Loader;\n" );
			rs.writeUTFBytes( "\n" );
			rs.writeUTFBytes( "\n" );
			//EmbeddedResource:
			rs.writeUTFBytes( "class EmbeddedResource\n" );
			rs.writeUTFBytes( "{\n" );
			rs.writeUTFBytes( "	public var _editorsPath : String;\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	public var _applicationDomain : ApplicationDomain;\n" );
			rs.writeUTFBytes( "	public var _frameRate : Number;\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	public function EmbeddedResource( editorsPath : String, swf : Class, onLoaded : Function )\n" );
			rs.writeUTFBytes( "	{\n" );
			rs.writeUTFBytes( "		_editorsPath = editorsPath;\n" );
			rs.writeUTFBytes( "		\n" );
			rs.writeUTFBytes( "		var mca : MovieClipAsset = new swf;\n" );
			rs.writeUTFBytes( "		var loader : Loader = Loader( mca.getChildAt( 0 ) );\n" );
			rs.writeUTFBytes( "		loader.contentLoaderInfo.addEventListener( Event.COMPLETE, function( event : Event ) : void\n" );
			rs.writeUTFBytes( "		{\n" );
			rs.writeUTFBytes( "			var info : LoaderInfo = LoaderInfo( event.target );\n" );
			rs.writeUTFBytes( "			_applicationDomain = info.applicationDomain;\n" );
			rs.writeUTFBytes( "			_frameRate = info.frameRate;\n" );
			rs.writeUTFBytes( "			\n" );
			rs.writeUTFBytes( "			onLoaded();\n" );
			rs.writeUTFBytes( "		} );\n" );
			rs.writeUTFBytes( "	}\n" );
			rs.writeUTFBytes( "}\n" );
			rs.writeUTFBytes( "\n" );
			//cached animation:
			rs.writeUTFBytes( "class CachedAnimation\n" );
			rs.writeUTFBytes( "{\n" );
			rs.writeUTFBytes( "	public var _animation : BliscAnimation;\n" );
			rs.writeUTFBytes( "	public var _editorsPath : String;\n" );
			rs.writeUTFBytes( "	public var _startingFrame : int;\n" );
			rs.writeUTFBytes( "	public var _endingFrame : int;\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	\n" );
			rs.writeUTFBytes( "	public function CachedAnimation( animation : BliscAnimation, editorsPath : String, startingFrame : int, endingFrame : int )\n" );
			rs.writeUTFBytes( "	{\n" );
			rs.writeUTFBytes( "		_animation = animation;\n" );
			rs.writeUTFBytes( "		_editorsPath = editorsPath;\n" );
			rs.writeUTFBytes( "		_startingFrame = startingFrame;\n" );
			rs.writeUTFBytes( "		_endingFrame = endingFrame;\n" );
			rs.writeUTFBytes( "	}\n" );
			rs.writeUTFBytes( "}\n" );
			rs.writeUTFBytes( "\n" );
			rs.writeUTFBytes( "\n" );
			
			var pngEncoder : PNGEncoder = new PNGEncoder;
			//to inform user about did optimizations - it's nice to read them:
			var animationsOptimizedDueToRequest : int = 0;
			var framesSkippedDueToRequest : int = 0;
			var animationsOptimizedDueToSimilarity : int = 0;
			var framesSkippedDueToSimilarity : int = 0;
			var totalAnimationsOptimized : int = 0;
			var totalFramesSkipped : int = 0;
			//animation frames sequencing:
			//handling only animations which used within units or complex objects templates:
			ns.writeInt( animationDescs.length );
			var framesData : ByteArray = new ByteArray;
			for each ( var animationDesc : AnimationDesc in animationDescs )
			{
				//checking if player specified frame skipping for current animation:
				var foundAnimationProperties : AnimationProperties = null;
				for each ( var sap : AnimationProperties in _project._data._animationProperties )
				{
					if ( sap._editorsPath == animationDesc._editorsPath && sap._animationName == animationDesc._name )
					{
						if ( sap._eachFrame > 1 )
						{
							foundAnimationProperties = sap;
						}
						break;
					}
				}
				
				//animation can be optimized here even better: checking for similarity regardless white-space, but not for now...
				
				var ssr : SingleResource = new SingleResource;
				ssr.Init( animationDesc._editorsPath, animationDesc._name );
				
				var sequencingAnimation : MovieClip = ssr.Display( _project ) as MovieClip;
				
				if ( sequencingAnimation == null )
				{
					PopUp( "Sequencing animation couldn't displayed", POP_UP_ERROR );
					return;
				}
				
				//for current purpose (generating ATF data instead of sequencing writing) it's not needed:
				/*//animations consisting from just 1 frame are fine:
				if ( sequencingAnimation.totalFrames < 2 )
				{
					continue;
				}*/
				
				ns.writeFloat( 1.0 / _project.FindResource( animationDesc._editorsPath )._FPS );
				
				//to inform user about changes:
				var requestOptimizationMentioned : Boolean = false;
				var similarityOptimizationMentioned : Boolean = false;
				var totalOmpimizationMentioned : Boolean = false;
				
				//prepare temp array first and write it only you're sure something was skipped:
				var resultingFrames : Vector.< int > = new < int >[ 1 ];
				
				var framesCount : int = 0;
				
				//last frame to compare with:
				var lastWrittenFrame : BliscSprite = null;
				var sequencingFrame : BliscSprite = null;
				for ( var sequencingIndex : int = 1; ; ++sequencingIndex )
				{
					if ( sequencingIndex > 1 )
					{
						if ( sequencingFrame != lastWrittenFrame && sequencingFrame != null )
						{
							framesData.writeBytes( pngEncoder.encode( sequencingFrame._source ) );
							lastWrittenFrame = sequencingFrame;
							
							++framesCount;
						}
						
						if ( sequencingIndex > sequencingAnimation.totalFrames )
						{
							break;
						}
						
						BliscAnimation.NextFrame( sequencingAnimation );
					}
					
					if ( foundAnimationProperties != null && sequencingIndex % foundAnimationProperties._eachFrame != 1 )
					{
						++framesSkippedDueToRequest;
						++totalFramesSkipped;
						
						if ( requestOptimizationMentioned == false )
						{
							++animationsOptimizedDueToRequest;
							requestOptimizationMentioned = true;
						}
						
						if ( totalOmpimizationMentioned == false )
						{
							++totalAnimationsOptimized;
							totalOmpimizationMentioned = true;
						}
						
						continue;
					}
					
					var nextSequencingFrame : BliscSprite = BliscAnimation.RenderFrame( sequencingAnimation );
					
					var differ : Boolean = false;
					if ( sequencingFrame == null )
					{
						differ = true;
					}
					else if (	nextSequencingFrame._source.width != sequencingFrame._source.width ||
								nextSequencingFrame._source.height != sequencingFrame._source.height )
					{
						differ = true;
					}
					else
					{
						for ( var row : int = 0; row < nextSequencingFrame._source.height; ++row )
						{
							for ( var column : int = 0; column < nextSequencingFrame._source.width; ++column )
							{
								if ( nextSequencingFrame._source.getPixel32( column, row ) != sequencingFrame._source.getPixel32( column, row ) )
								{
									differ = true;
									break;
								}
							}
							
							if ( differ )
							{
								break;
							}
						}
					}
					
					if ( differ )
					{
						sequencingFrame = nextSequencingFrame;
						resultingFrames.push( sequencingIndex );
					}
					else
					{
						++framesSkippedDueToSimilarity;
						++totalFramesSkipped;
						
						if ( similarityOptimizationMentioned == false )
						{
							++animationsOptimizedDueToSimilarity;
							similarityOptimizationMentioned = true;
						}
						
						if ( totalOmpimizationMentioned == false )
						{
							++totalAnimationsOptimized;
							totalOmpimizationMentioned = true;
						}
					}
				}
				
				ns.writeInt( framesCount );
				
				ns.writeBytes( framesData );
			}
			
			rs.close();
			bs.close();
			ns.close();
			ms.close();
			
			if ( wasError == false )
			{
				var sgr : SourcesGenerationResult = PopUpManager.createPopUp( this, SourcesGenerationResult, true ) as SourcesGenerationResult;
				sgr.Init(
					animationsOptimizedDueToRequest,
					framesSkippedDueToRequest,
					animationsOptimizedDueToSimilarity,
					framesSkippedDueToSimilarity,
					totalAnimationsOptimized,
					totalFramesSkipped
				);
				PopUpManager.centerPopUp( sgr );
			}
		}
		
		private function set projectPath( value : String ) : void
		{
			_menuBar.getMenuAt( 0 ).dataProvider[ 1 ].@enabled = true;
			
			_projectPath = value;
		}
		
		private function SaveProject( path:String ): void
		{
			var savingStream:FileStream = new FileStream;
			try
			{
				savingStream.open( new File( path ), FileMode.WRITE );
			}
			catch ( e:Error )
			{
				PopUp( "Saving failed: file \"" + path + "\" was NOT opened: " + e.message, POP_UP_ERROR );
				return;
			}
			
			savingStream.writeBytes( _project.DataToSave() );
			savingStream.close();
			PopUp( "Project file successfully saved.", POP_UP_INFO );
		}
		
		public function AddTemplate( complexTemplate : ComplexTemplate = null ): void
		{
			_project.AddObjectTemplate( complexTemplate == null ? new ComplexTemplate : complexTemplate );
		}
		
		public function AddCompound( compoundTemplate : CompoundTemplate = null ): void
		{
			_project.AddObjectTemplate( compoundTemplate == null ? new CompoundTemplate : compoundTemplate );
		}
		
		public function AddMap(): void
		{
			var map:Map = new Map;
			
			_project.AddMap( map );
		}
		
		public function AddLayer(): void
		{
			_project._data._layers.push( new Layer );
			UpdateLayersList();
			
			_isometry.Reinit();
		}
		
		public function AddRegion(): void
		{
			var newRegion:Region = new Region;
			_project._data._regions.push( newRegion );
			_regions_list.dataProvider.addItem( new RegionListItem( newRegion ) );
		}
		
		public function UpdateLayersList(): void
		{
			for each ( var destroyingListItem:LayerListItem in _layers_list_data_provider.source )
			{
				destroyingListItem.Destroy();
			}
			_layers_list_data_provider.source.length = 0;
			_layers_list_data_provider.source = [];
			
			for ( var i:int = 0; i < _project._data._layers.length; ++i )
			{
				var layer : Layer = _project._data._layers[ i ];
				_layers_list_data_provider.addItem( new LayerListItem( layer._name, layer, i ) );
			}
		}
		
		private function onIsometryDragEnter( event:DragEvent ): void
		{
			_isometry.onDragEnter( event );
		}
		
		private function onIsometryDragOver( event:DragEvent ): void
		{
			_isometry.onDragOver( event );
		}
		
		private function onIsometryDragDrop( event:DragEvent ): void
		{
			_isometry.onDragDrop( event );
		}
		
		
		public function ShowObjectProperties(): void
		{
			if ( _isometry._selected == null || _isometry._selected is Unit )
			{
				_instanceProperties.enabled = false;
				return;
			}
			
			_instanceProperties.enabled = true;
			
			_objectName.text = _isometry._selected._objectInstance._template._name;
			const isoX:Number = _isometry._selected._objectInstance._tileCoords.x * _project.side;
			const isoY:Number = _isometry._selected._objectInstance._tileCoords.y * _project.side;
			_objectIsoX.text = isoX.toString();
			_objectIsoY.text = isoY.toString();
			_objectTileX.text = _isometry._selected._objectInstance._tileCoords.x.toString();
			_objectTileY.text = _isometry._selected._objectInstance._tileCoords.y.toString();
			var flat:Point = Utils.FromIso( isoX, isoY, new Point );
			_objectFlatX.text = flat.x.toString();
			_objectFlatY.text = flat.y.toString();
		}
		public function SetObjectTilePos( x:Number, y:Number ): void
		{
			if ( _isometry._selected != null )
			{
				_isometry._selected._objectInstance._tileCoords.setTo( x, y );
				_isometry._selected._view.SetTileX( x );
				_isometry._selected._view.SetTileY( y );
			}
			
			ShowObjectProperties();
		}
		private function SetObjectPosFromIso(): void
		{
			SetObjectTilePos( parseFloat( _objectIsoX.text ) / _project.side, parseFloat( _objectIsoY.text ) / _project.side );
		}
		private function onObjectIsoXChange( ... args ): void
		{
			SetObjectPosFromIso();
		}
		private function onObjectIsoYChange( ... args ): void
		{
			SetObjectPosFromIso();
		}
		private function SetObjectPosFromTile(): void
		{
			SetObjectTilePos( parseFloat( _objectTileX.text ), parseFloat( _objectTileY.text ) );
		}
		private function onObjectTileXChange( ... args ): void
		{
			SetObjectPosFromTile();
		}
		private function onObjectTileYChange( ... args ): void
		{
			SetObjectPosFromTile();
		}
		private function SetObjectPosFromFlat(): void
		{
			var iso:Point = Utils.ToIso( parseFloat( _objectFlatX.text ), parseFloat( _objectFlatY.text ), new Point );
			SetObjectTilePos( iso.x, iso.y );
		}
		private function onObjectFlatXChange( ... args ): void
		{
			SetObjectPosFromFlat();
		}
		private function onObjectFlatYChange( ... args ): void
		{
			SetObjectPosFromFlat();
		}
		
		
		private function onRegionChoice( e:IndexChangeEvent ): void
		{
			trace( "region" );
		}
		
		public var _regionContextMenu:Menu = null;
		private function onRegionContextMenu( e:MouseEvent ): void
		{
			var thisOne:Main = this;
			
			if ( _regionContextMenu != null )
			{
				_regionContextMenu.hide();
				_regionContextMenu = null;
			}
			
			var menuData:Array = [ { label : "Add region...", id : "add_region" } ];
			var regionListItem:RegionListItem = FindListItem( e, RegionListItem ) as RegionListItem;
			if ( regionListItem != null )
			{
				menuData = menuData.concat( [ { label: "Edit...", id: "edit", region: regionListItem.region } ] );
			}
			
			_regionContextMenu = Menu.createMenu( null, menuData );
			_regionContextMenu.addEventListener( MenuEvent.ITEM_CLICK, function( menuEvent:MenuEvent ): void
			{
				switch ( menuEvent.item.id )
				{
					case "add_region":
						_changeMade = true;
						AddRegion();
						break;
					
					case "edit":
						var editingRegionWindow : EditingRegionWindow = PopUpManager.createPopUp( thisOne, EditingRegionWindow, false ) as EditingRegionWindow;
						editingRegionWindow.Init( _project, menuEvent.item.region, thisOne );
						PopUpManager.centerPopUp( editingRegionWindow );
						break;
				}
			} );
			_regionContextMenu.show( e.stageX, e.stageY );
		}
		
		
		private function onDrawBorderFlagChange( ... args ) : void
		{
			if ( _isometry.displaying == null )
			{
				return;
			}
			
			_isometry.displaying._drawBorder = _drawBorder.selected;
		}
		private function onDrawGridFlagChange( ... args ): void
		{
			if ( _isometry.displaying == null )
			{
				return;
			}
			
			_isometry.displaying._drawGrid = _drawGrid.selected;
		}
		
		private function onClampToTileFlagChange( ... args ): void
		{
			if ( _isometry.displaying == null )
			{
				return;
			}
			
			_isometry.displaying._clampToTiles = _clampToTile.selected;
		}
		
		private function onUnitsSpeedChange( ... args ): void
		{
			if ( _isometry.displaying == null )
			{
				return;
			}
			
			_reloadMapButton.enabled = true;
			
			_isometry.displaying._unitsSpeed = parseFloat( _unitsSpeed.text );
		}
		
		
		
		private function onResourcesPreviewHolderResize( ... args ): void
		{
			_resourcesPreview.Resize( _resources_preview_holder.width, _resources_preview_holder.height );
		}
		
		
		private function SetScale( value:Number ): void
		{
			if ( _isometry._blisc != null )
			{
				_isometry._blisc.zoom = value;
			}
		}
		private function onScale_1( ... args ): void
		{
			SetScale( 1 );
		}
		private function onScale_2( ... args ): void
		{
			SetScale( 1 / 2 );
		}
		private function onScale_3( ... args ): void
		{
			SetScale( 1 / 3 );
		}
		private function onScale_4( ... args ): void
		{
			SetScale( 1 / 4 );
		}
		
		
		private function onReloadMap( ... args ): void
		{
			_isometry.Reinit();
			_reloadMapButton.enabled = false;
		}
		
		
		private function Position( object : ObjectTemplate ) : void
		{
			if ( _isometry.displaying == null )
			{
				PopUp( "Choose some map first.", POP_UP_ERROR );
			}
			else
			{
				_isometry.Position( object );
			}
		}
		
		
		private function onThroughChange( ... args ) : void
		{
			if ( _isometry._blisc != null )
			{
				_isometry._blisc._selection = _through.selected ? Blisc.SELECTION_FIRST : Blisc.SELECTION_LAST;
			}
		}
		
		
		public function get moving() : Boolean
		{
			return _move.selected;
		}
		
		
		]]>
	</fx:Script>
	
</s:Application>

