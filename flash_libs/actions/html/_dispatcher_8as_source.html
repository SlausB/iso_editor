<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>&quot;Actions&quot;: Исходный файл actions/Dispatcher.as</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Создано системой Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">"Actions"</div>
   <div id="projectbrief">Библиотека для упорядоченного совершения действий.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li><a href="pages.html"><span>Описания</span></a></li>
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li class="current"><a href="files.html"><span>Файлы</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Файлы</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>actions/Dispatcher.as</h1>  </div>
</div>
<div class="contents">
<a href="_dispatcher_8as.html">См. документацию.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 ﻿
<a name="l00002"></a>00002 <span class="keyword">package </span>actions
<a name="l00003"></a>00003 {
<a name="l00004"></a>00004         import actions.Action;
<a name="l00005"></a>00005         <span class="keyword">import</span> actions.ActionAsTask;
<a name="l00006"></a>00006         <span class="keyword">import</span> actions.ActionCreationResult;
<a name="l00007"></a>00007         <span class="keyword">import</span> actions.ActionDesc;
<a name="l00008"></a>00008         <span class="keyword">import</span> actions.Queue;
<a name="l00009"></a>00009         
<a name="l00011"></a>00011         
<a name="l00013"></a><a class="code" href="class_dispatcher.html">00013</a>         <span class="keyword">public</span> <span class="keyword">class </span><a class="code" href="class_dispatcher.html" title="Хранит очереди. Вызывает выполнение их действий.">Dispatcher</a> 
<a name="l00014"></a>00014         {
<a name="l00016"></a><a class="code" href="class_dispatcher.html#a444be279c8e063c48172de555641078e">00016</a>                 <span class="keyword">private</span> var output:Output;
<a name="l00017"></a>00017                 
<a name="l00019"></a><a class="code" href="class_dispatcher.html#ac9e433b4f69da64fa2390fd87e626192">00019</a>                 <span class="keyword">private</span> var ignoringQueues:Array = [];
<a name="l00020"></a>00020                 
<a name="l00022"></a><a class="code" href="class_dispatcher.html#a47926a4469c2cd78f9c691087f116a66">00022</a>                 <span class="keyword">private</span> var ignoringThreads:Array = [];
<a name="l00023"></a>00023                 
<a name="l00025"></a><a class="code" href="class_dispatcher.html#a36e140b2fbe14d6a4c65ff969094e5be">00025</a>                 <span class="keyword">private</span> var queues:Array = [];
<a name="l00026"></a>00026                 
<a name="l00028"></a><a class="code" href="class_dispatcher.html#abc271fb846a89472d4b89274b14c248b">00028</a>                 <span class="keyword">private</span> var redirections:Array = [];
<a name="l00029"></a>00029                 
<a name="l00031"></a><a class="code" href="class_dispatcher.html#a0ec796574ced8b4ededca38f67a4a58e">00031</a>                 <span class="keyword">public</span> var queueOfCurrentAction:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = null;
<a name="l00032"></a>00032                 
<a name="l00033"></a>00033                 
<a name="l00034"></a>00034                 
<a name="l00035"></a>00035                 
<a name="l00037"></a><a class="code" href="class_dispatcher.html#a45ff3b6d4d29ebd9a2b8e62c6cd3c04d">00037</a>                 <span class="keyword">public</span> <span class="keyword">static</span> function Task_Default(param:<a class="code" href="class_param.html">Param</a>): void
<a name="l00038"></a>00038                 {
<a name="l00039"></a>00039                         param.queue.ActionEnded();
<a name="l00040"></a>00040                 }
<a name="l00041"></a>00041                 
<a name="l00042"></a>00042                 
<a name="l00043"></a>00043                 
<a name="l00046"></a><a class="code" href="class_dispatcher.html#ac01cf2bcaf244beaccda06c749f2130b">00046</a>                 <span class="keyword">public</span> function <a class="code" href="class_dispatcher.html" title="Хранит очереди. Вызывает выполнение их действий.">Dispatcher</a>(output:Output): void
<a name="l00047"></a>00047                 {
<a name="l00048"></a>00048                         this.output = output;
<a name="l00049"></a>00049                 }
<a name="l00050"></a>00050                 
<a name="l00057"></a><a class="code" href="class_dispatcher.html#acf8f1f43617c22280960f9d1c80733d4">00057</a>                 <span class="keyword">public</span> function Live(elapsedSeconds:Number = 0.020, thread:<span class="keywordtype">int</span> = 0): void
<a name="l00058"></a>00058                 {
<a name="l00059"></a>00059                         <span class="keywordflow">if</span>(elapsedSeconds &lt; 0.0)
<a name="l00060"></a>00060                         {
<a name="l00061"></a>00061                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher::Live(): elapsedTimeInSeconds = &quot;</span> + elapsedSeconds + <span class="stringliteral">&quot; is wrong. It must be &gt;= 0. Returning.\n&quot;</span>, Output.ERROR);
<a name="l00062"></a>00062                                 <span class="keywordflow">return</span>;
<a name="l00063"></a>00063                         }
<a name="l00064"></a>00064                         
<a name="l00065"></a>00065                         <span class="comment">//если указанный поток входит в список игнорируемых, то ничего не делаем:</span>
<a name="l00066"></a>00066                         <span class="keywordflow">if</span>(thread &gt;= 0)
<a name="l00067"></a>00067                         {
<a name="l00068"></a>00068                                 <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; ignoringThreads.length; i++)
<a name="l00069"></a>00069                                 {
<a name="l00070"></a>00070                                         <span class="keywordflow">if</span>(thread == ignoringThreads[i] || ignoringThreads[i] == -1)
<a name="l00071"></a>00071                                         {
<a name="l00072"></a>00072                                                 <span class="keywordflow">return</span>;
<a name="l00073"></a>00073                                         }
<a name="l00074"></a>00074                                 }
<a name="l00075"></a>00075                         }
<a name="l00076"></a>00076                         <span class="keywordflow">else</span>
<a name="l00077"></a>00077                         {
<a name="l00078"></a>00078                                 output.Out(<span class="stringliteral">&quot;W: Dispatcher::Live(): thread = &quot;</span> + thread + <span class="stringliteral">&quot; is wrong. It must be positive.\n&quot;</span>, Output.WARN);
<a name="l00079"></a>00079                         }
<a name="l00080"></a>00080                         
<a name="l00081"></a>00081                         <span class="comment">//проход по вектору очередей:</span>
<a name="l00082"></a>00082                         <span class="keywordflow">for</span> (var forEachQueue:<span class="keywordtype">int</span> = 0; forEachQueue &lt; redirections.length; forEachQueue++)
<a name="l00083"></a>00083                         {
<a name="l00084"></a>00084                                 <span class="comment">//индекс текущей очереди в векторе очередей:</span>
<a name="l00085"></a>00085                                 var currentQueueIndex:<span class="keywordtype">int</span> = redirections[forEachQueue].index;
<a name="l00086"></a>00086                                 
<a name="l00087"></a>00087                                 <span class="comment">//нужно ли перейти к следующей очереди:</span>
<a name="l00088"></a>00088                                 var goToNextQueue:Boolean = <span class="keyword">false</span>;
<a name="l00089"></a>00089                                 
<a name="l00090"></a>00090                                 <span class="comment">//если текущая очередь одна из игнорируемых очередей, то пропускаем её:</span>
<a name="l00091"></a>00091                                 <span class="keywordflow">for</span>(var forEachIgnoringQueues:<span class="keywordtype">int</span> = 0; forEachIgnoringQueues &lt; ignoringQueues.length; forEachIgnoringQueues++)
<a name="l00092"></a>00092                                 {
<a name="l00093"></a>00093                                         <span class="comment">//если указано игнорировать все очереди:</span>
<a name="l00094"></a>00094                                         <span class="keywordflow">if</span>(ignoringQueues[forEachIgnoringQueues] == -1)
<a name="l00095"></a>00095                                         {
<a name="l00096"></a>00096                                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.Execute(): ignoring ALL queues.\n&quot;</span>, Output.INFO);
<a name="l00097"></a>00097                                                 <span class="keywordflow">return</span>;
<a name="l00098"></a>00098                                         }
<a name="l00099"></a>00099                                         
<a name="l00100"></a>00100                                         <span class="comment">//если указано игнорировать именно эту очередь:</span>
<a name="l00101"></a>00101                                         <span class="keywordflow">if</span>(ignoringQueues[forEachIgnoringQueues] == redirections[forEachQueue].<span class="keywordtype">id</span>)
<a name="l00102"></a>00102                                         {
<a name="l00103"></a>00103                                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.Execute(): queue with index &quot;</span> + currentQueueIndex + <span class="stringliteral">&quot; and id &quot;</span> + redirections[forEachQueue].<span class="keywordtype">id</span> + <span class="stringliteral">&quot; ignored.\n&quot;</span>, Output.INFO);
<a name="l00104"></a>00104                                                 goToNextQueue = <span class="keyword">true</span>;
<a name="l00105"></a>00105                                                 <span class="keywordflow">break</span>;
<a name="l00106"></a>00106                                         }
<a name="l00107"></a>00107                                 }
<a name="l00108"></a>00108                                 <span class="keywordflow">if</span>(goToNextQueue == <span class="keyword">true</span>)
<a name="l00109"></a>00109                                 {
<a name="l00110"></a>00110                                         <span class="keywordflow">continue</span>;
<a name="l00111"></a>00111                                 }
<a name="l00112"></a>00112                                 
<a name="l00113"></a>00113                                 <span class="comment">//текущая очередь:</span>
<a name="l00114"></a>00114                                 var queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = queues[currentQueueIndex];
<a name="l00115"></a>00115                                 <span class="comment">//чтобы действие могло получить очередь, в которой оно находится, из переданного в неё Dispatcher:</span>
<a name="l00116"></a>00116                                 queueOfCurrentAction = queue;
<a name="l00117"></a>00117                                 <span class="comment">//сколько времени могут потребить действия в текущей очереди:</span>
<a name="l00118"></a>00118                                 var needToConsumeSecondsForCurrentQueue:Number = elapsedSeconds;
<a name="l00119"></a>00119                                 
<a name="l00120"></a>00120                                 <span class="comment">//выполнение действий в очереди до тех пор, пока они не потребят всё время или не закончатся:</span>
<a name="l00121"></a>00121                                 <span class="keywordflow">for</span> (;;)
<a name="l00122"></a>00122                                 {
<a name="l00123"></a>00123                                         <span class="comment">//получение следующего действия для выполнения:</span>
<a name="l00124"></a>00124                                         var action:<a class="code" href="class_action.html" title="Абстрактный класс действия внутри очереди.">Action</a> = queue.CurrentAction();
<a name="l00125"></a>00125                                         <span class="comment">//если действия закончились или их просто нет:</span>
<a name="l00126"></a>00126                                         <span class="keywordflow">if</span>(action == null)
<a name="l00127"></a>00127                                         {
<a name="l00128"></a>00128                                                 <span class="keywordflow">break</span>;
<a name="l00129"></a>00129                                         }
<a name="l00130"></a>00130                                         
<a name="l00131"></a>00131                                         <span class="comment">//если действие выполняется впервые, то очищаем его данные, ибо с ними нельзя будет работать корректно:</span>
<a name="l00132"></a>00132                                         <span class="keywordflow">if</span>(queue.doneCycles &lt;= 0)
<a name="l00133"></a>00133                                         {
<a name="l00134"></a>00134                                                 <span class="comment">//верхним уровнем действий могут быть только действия ActionAsTask:</span>
<a name="l00135"></a>00135                                                 (action as <a class="code" href="class_action_as_task.html" title="Простой вызов функции (действие) с параметрами внутри очереди.">ActionAsTask</a>).data.length = 0;
<a name="l00136"></a>00136                                         }
<a name="l00137"></a>00137                                         <span class="comment">//выполнение действия:</span>
<a name="l00138"></a>00138                                         <span class="keyword">const</span> consumedSeconds:Number = action.<a class="code" href="class_action.html#ad6cffab9f080270363ad2f9bf2623dca" title="Вызывается очередью, в которой хранится это задание.">Execute</a>(<span class="keyword">this</span>, needToConsumeSecondsForCurrentQueue);
<a name="l00139"></a>00139                                         <span class="comment">//если действие ещё не закончилось:</span>
<a name="l00140"></a>00140                                         <span class="keywordflow">if</span>(queue.wasActionEnded == <span class="keyword">false</span>)
<a name="l00141"></a>00141                                         {
<a name="l00142"></a>00142                                                 queue.doneCycles++;
<a name="l00143"></a>00143                                                 <span class="comment">//в Action::Execute() действие должно было вызываться до тех пор, пока оно не потребит всё время, поэтому цикл выполнен:</span>
<a name="l00144"></a>00144                                                 <span class="keywordflow">break</span>;
<a name="l00145"></a>00145                                         }
<a name="l00146"></a>00146                                         <span class="comment">//действие закончилось, поэтому сбрасываем флаг для следующего действия:</span>
<a name="l00147"></a>00147                                         <span class="keywordflow">else</span>
<a name="l00148"></a>00148                                         {
<a name="l00149"></a>00149                                                 queue.wasActionEnded = <span class="keyword">false</span>;
<a name="l00150"></a>00150                                                 queue.wasActionMarkedAsEnded = <span class="keyword">false</span>;
<a name="l00151"></a>00151                                                 <span class="keywordflow">if</span>(queue.remainOnCurrentAction)
<a name="l00152"></a>00152                                                 {
<a name="l00153"></a>00153                                                         queue.remainOnCurrentAction = <span class="keyword">false</span>;
<a name="l00154"></a>00154                                                 }
<a name="l00155"></a>00155                                                 <span class="keywordflow">else</span>
<a name="l00156"></a>00156                                                 {
<a name="l00157"></a>00157                                                         queue.currentAction++;
<a name="l00158"></a>00158                                                 }
<a name="l00159"></a>00159                                                 queue.doneCycles = 0;
<a name="l00160"></a>00160                                                 
<a name="l00161"></a>00161                                                 <span class="comment">//если потреблённое время было указано неверно или действие, по счастливой случайности, потребило всё время, то переходим к следующей очереди:</span>
<a name="l00162"></a>00162                                                 <span class="keywordflow">if</span>(consumedSeconds &gt;= needToConsumeSecondsForCurrentQueue)
<a name="l00163"></a>00163                                                 {
<a name="l00164"></a>00164                                                         <span class="keywordflow">break</span>;
<a name="l00165"></a>00165                                                 }
<a name="l00166"></a>00166                                                 <span class="comment">//пересчитываем сколько времени осталось для следующего действия:</span>
<a name="l00167"></a>00167                                                 needToConsumeSecondsForCurrentQueue -= consumedSeconds;
<a name="l00168"></a>00168                                         }
<a name="l00169"></a>00169                                 }
<a name="l00170"></a>00170                         }
<a name="l00171"></a>00171                 }
<a name="l00172"></a>00172                 
<a name="l00179"></a><a class="code" href="class_dispatcher.html#a1f69c545a08d8836d54c5a12514a588c">00179</a>                 <span class="keyword">public</span> function Clear(queueId:<span class="keywordtype">int</span> = -1, resetIgnoring:Boolean = <span class="keyword">false</span>, ... exceptions): void
<a name="l00180"></a>00180                 {
<a name="l00181"></a>00181                         <span class="comment">//если по-умолчанию указано удалить все очереди:</span>
<a name="l00182"></a>00182                         <span class="keywordflow">if</span>(queueId == -1)
<a name="l00183"></a>00183                         {
<a name="l00184"></a>00184                                 <span class="comment">//если нужно удалить очереди с исключениями:</span>
<a name="l00185"></a>00185                                 <span class="keyword">const</span> exceptionsCount:<span class="keywordtype">int</span> = exceptions.length;
<a name="l00186"></a>00186                                 <span class="keywordflow">if</span>(exceptionsCount &gt; 0)
<a name="l00187"></a>00187                                 {
<a name="l00188"></a>00188                                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.Clear(): removing queues with &quot;</span> + exceptionsCount + <span class="stringliteral">&quot; exceptions:\n&quot;</span>, Output.INFO);
<a name="l00189"></a>00189                                         <span class="keywordflow">for</span>(var exception:<span class="keywordtype">int</span> = 0; exception &lt; exceptionsCount; exception++)
<a name="l00190"></a>00190                                         {
<a name="l00191"></a>00191                                                 output.Out(<span class="stringliteral">&quot;    &quot;</span> + exceptions[exception] + <span class="stringliteral">&quot;\n&quot;</span>, Output.INFO);
<a name="l00192"></a>00192                                         }
<a name="l00193"></a>00193                                         
<a name="l00194"></a>00194                                         <span class="comment">//удаление всех очередей по-одной, кроме исключений:</span>
<a name="l00195"></a>00195                                         <span class="keywordflow">for</span>(var removingQueue:<span class="keywordtype">int</span> = 0; removingQueue &lt; queues.length; removingQueue++)
<a name="l00196"></a>00196                                         {
<a name="l00197"></a>00197                                                 <span class="comment">//является ли текущая очередь исключением:</span>
<a name="l00198"></a>00198                                                 var isException:Boolean = <span class="keyword">false</span>;
<a name="l00199"></a>00199                                                 <span class="comment">//идентификатор удаляемой очереди:</span>
<a name="l00200"></a>00200                                                 var removingQueueId:<span class="keywordtype">int</span> = QueueIdFromIndex(removingQueue);
<a name="l00201"></a>00201                                                 <span class="comment">//если, по непонятным причинам, очереди с таким индексом нету:</span>
<a name="l00202"></a>00202                                                 <span class="keywordflow">if</span>(removingQueueId == -1)
<a name="l00203"></a>00203                                                 {
<a name="l00204"></a>00204                                                         output.Out(<span class="stringliteral">&quot;W: Dispatcher::Clear(): impossible happened: queue with index = &quot;</span> + removingQueue + <span class="stringliteral">&quot; does not exist.\n&quot;</span>, Output.WARN);
<a name="l00205"></a>00205                                                         <span class="keywordflow">continue</span>;
<a name="l00206"></a>00206                                                 }
<a name="l00207"></a>00207                                                 <span class="comment">//поиск текущей очереди в исключениях:</span>
<a name="l00208"></a>00208                                                 <span class="keywordflow">for</span>(var anotherException:<span class="keywordtype">int</span> = 0; anotherException &lt; exceptionsCount; anotherException++)
<a name="l00209"></a>00209                                                 {
<a name="l00210"></a>00210                                                         <span class="keywordflow">if</span>(removingQueueId == exceptions[anotherException])
<a name="l00211"></a>00211                                                         {
<a name="l00212"></a>00212                                                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher::Clear(): queue with id &quot;</span> + removingQueueId + <span class="stringliteral">&quot; is exception.\n&quot;</span>, Output.INFO);
<a name="l00213"></a>00213                                                                 isException     = <span class="keyword">true</span>;
<a name="l00214"></a>00214                                                                 <span class="keywordflow">break</span>;
<a name="l00215"></a>00215                                                         }
<a name="l00216"></a>00216                                                 }
<a name="l00217"></a>00217                                                 <span class="comment">//если текущая очередь в исключениях, то её удалять не нужно:</span>
<a name="l00218"></a>00218                                                 <span class="keywordflow">if</span>(isException  == <span class="keyword">true</span>)
<a name="l00219"></a>00219                                                 {
<a name="l00220"></a>00220                                                         <span class="keywordflow">continue</span>;
<a name="l00221"></a>00221                                                 }
<a name="l00222"></a>00222                                                 <span class="keywordflow">else</span>
<a name="l00223"></a>00223                                                 {
<a name="l00224"></a>00224                                                         output.Out(<span class="stringliteral">&quot;I: Dispatcher::Clear(): queue with id &quot;</span> + removingQueueId + <span class="stringliteral">&quot; is NOT exception.\n&quot;</span>, Output.INFO);
<a name="l00225"></a>00225                                                 }
<a name="l00226"></a>00226                                                 
<a name="l00227"></a>00227                                                 <span class="comment">//удаление текущей очереди:</span>
<a name="l00228"></a>00228                                                 ClearQueue(removingQueueId, resetIgnoring);
<a name="l00229"></a>00229                                         }
<a name="l00230"></a>00230                                 }
<a name="l00231"></a>00231                                 <span class="comment">//в противном случае просто удаляем все очереди (без исключений):</span>
<a name="l00232"></a>00232                                 <span class="keywordflow">else</span>
<a name="l00233"></a>00233                                 {
<a name="l00234"></a>00234                                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; queues.length; i++)
<a name="l00235"></a>00235                                         {
<a name="l00236"></a>00236                                                 <span class="comment">//очистка массива действий внутри каждой очереди действий:</span>
<a name="l00237"></a>00237                                                 queues[i].Clear();
<a name="l00238"></a>00238                                                 
<a name="l00239"></a>00239                                                 <span class="comment">//удаление соответствующей очереди:</span>
<a name="l00240"></a>00240                                                 <span class="keyword">delete</span> queues[i];
<a name="l00241"></a>00241                                         }
<a name="l00242"></a>00242                                         
<a name="l00243"></a>00243                                         <span class="comment">//удаление всех указателей на очереди:</span>
<a name="l00244"></a>00244                                         queues.length = 0;
<a name="l00245"></a>00245                                         <span class="comment">//очистка всех перенаправлений:</span>
<a name="l00246"></a>00246                                         redirections.length = 0;
<a name="l00247"></a>00247                                         
<a name="l00248"></a>00248                                         <span class="comment">//отменяем игнорирование всех очередей:</span>
<a name="l00249"></a>00249                                         ignoringQueues.length = 0;
<a name="l00250"></a>00250                                         
<a name="l00251"></a>00251                                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.Clear(): all queues deleted successfully. All ignorings removed.\n&quot;</span>, Output.INFO);
<a name="l00252"></a>00252                                 }
<a name="l00253"></a>00253                                 <span class="keywordflow">return</span>;
<a name="l00254"></a>00254                         }
<a name="l00255"></a>00255                         
<a name="l00256"></a>00256                         <span class="comment">//удаляем единственную указанную очередь:</span>
<a name="l00257"></a>00257                         ClearQueue(queueId, resetIgnoring);
<a name="l00258"></a>00258                 }
<a name="l00259"></a>00259                 
<a name="l00263"></a><a class="code" href="class_dispatcher.html#a66b1903dc4fc1688e2f44b4d4246fb45">00263</a>                 <span class="keyword">public</span> function ClearQueue(queueId:<span class="keywordtype">int</span>, resetIgnoring:Boolean = <span class="keyword">false</span>): void
<a name="l00264"></a>00264                 {
<a name="l00265"></a>00265                         <span class="keywordflow">if</span>(queueId &lt; 0)
<a name="l00266"></a>00266                         {
<a name="l00267"></a>00267                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.DeleteQueue(): queueId = &quot;</span> + queueId + <span class="stringliteral">&quot;. It must be positive or = -1.\n&quot;</span>, Output.ERROR);
<a name="l00268"></a>00268                                 <span class="keywordflow">return</span>;
<a name="l00269"></a>00269                         }
<a name="l00270"></a>00270                         
<a name="l00271"></a>00271                         <span class="comment">//поиск очереди с указанным идентификатором:</span>
<a name="l00272"></a>00272                         var foundQueue:<span class="keywordtype">int</span> = QueueIndexFromId(queueId);
<a name="l00273"></a>00273                         <span class="comment">//если очереди с указанным индексом так и не было найдено:</span>
<a name="l00274"></a>00274                         <span class="keywordflow">if</span>(foundQueue == -1)
<a name="l00275"></a>00275                         {
<a name="l00276"></a>00276                                 output.Out(<span class="stringliteral">&quot;W: Dispatcher.DeleteQueue(): there are NO queue with id = &quot;</span> + queueId + <span class="stringliteral">&quot;.\n&quot;</span>, Output.WARN);
<a name="l00277"></a>00277                                 <span class="keywordflow">return</span>;
<a name="l00278"></a>00278                         }
<a name="l00279"></a>00279                         
<a name="l00280"></a>00280                         <span class="comment">//очищаем очередь с указанным индексом:</span>
<a name="l00281"></a>00281                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.DeleteQueue(): clearing queue with index = &quot;</span> + foundQueue + <span class="stringliteral">&quot;.\n&quot;</span>, Output.INFO);
<a name="l00282"></a>00282                         queues[foundQueue].Clear();
<a name="l00283"></a>00283                         
<a name="l00284"></a>00284                         <span class="comment">//если указано, то отменяем игнорирование указанной очереди:</span>
<a name="l00285"></a>00285                         <span class="comment">//поиск указанной очереди в списке игнорируемых очередей и замена на такое число, индекса очереди которой точно не будет:</span>
<a name="l00286"></a>00286                         <span class="keywordflow">if</span>(resetIgnoring == <span class="keyword">true</span>)
<a name="l00287"></a>00287                         {
<a name="l00288"></a>00288                                 <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; ignoringQueues.length; i++)
<a name="l00289"></a>00289                                 {
<a name="l00290"></a>00290                                         <span class="keywordflow">if</span>(ignoringQueues[i] == queueId)
<a name="l00291"></a>00291                                         {
<a name="l00292"></a>00292                                                 ignoringQueues[i] = -2;
<a name="l00293"></a>00293                                         }
<a name="l00294"></a>00294                                 }
<a name="l00295"></a>00295                         }
<a name="l00296"></a>00296                         
<a name="l00297"></a>00297                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.DeleteQueue(): queue with id = &quot;</span> + queueId + <span class="stringliteral">&quot; cleared.\n&quot;</span>, Output.INFO);
<a name="l00298"></a>00298                 }
<a name="l00299"></a>00299                 
<a name="l00304"></a><a class="code" href="class_dispatcher.html#ac58b490fe4785de278379c8b433c0c4d">00304</a>                 <span class="keyword">public</span> function IgnoreThread(thread:<span class="keywordtype">int</span> = -1): void
<a name="l00305"></a>00305                 {
<a name="l00306"></a>00306                         <span class="comment">//идентификатор игнорируемого потока должен быть положительным:</span>
<a name="l00307"></a>00307                         <span class="keywordflow">if</span>(thread &lt; -1)
<a name="l00308"></a>00308                         {
<a name="l00309"></a>00309                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.IgnoreThread(): thread = &quot;</span> + thread + <span class="stringliteral">&quot;. It must be positive or = -1. Thread will NOT be added as ignored.\n&quot;</span>, Output.ERROR);
<a name="l00310"></a>00310                                 <span class="keywordflow">return</span>;
<a name="l00311"></a>00311                         }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313                         <span class="comment">//добавляем поток в список игнорируемых потоков:</span>
<a name="l00314"></a>00314                         ignoringThreads.push(thread);
<a name="l00315"></a>00315                 }
<a name="l00316"></a>00316                 
<a name="l00320"></a><a class="code" href="class_dispatcher.html#af678dc0e1927554c1c96c8825878edfb">00320</a>                 <span class="keyword">public</span> function ResetThreadIgnoring(thread:<span class="keywordtype">int</span> = -1): void
<a name="l00321"></a>00321                 {
<a name="l00322"></a>00322                         <span class="comment">//если указано -1, то отменяем игнорирование всех очередей:</span>
<a name="l00323"></a>00323                         <span class="keywordflow">if</span>(thread == -1)
<a name="l00324"></a>00324                         {
<a name="l00325"></a>00325                                 ignoringThreads.length = 0;
<a name="l00326"></a>00326                                 <span class="keywordflow">return</span>;
<a name="l00327"></a>00327                         }
<a name="l00328"></a>00328                         
<a name="l00329"></a>00329                         <span class="comment">//поиск указанного потока в потоках, которые уже игнорируются:</span>
<a name="l00330"></a>00330                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; ignoringThreads.length; i++)
<a name="l00331"></a>00331                         {
<a name="l00332"></a>00332                                 <span class="keywordflow">if</span>(ignoringThreads[i] == thread)
<a name="l00333"></a>00333                                 {
<a name="l00334"></a>00334                                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.ResetThreadIgnoring(): thread &quot;</span> + thread + <span class="stringliteral">&quot; found. Changing it to -2.\n&quot;</span>, Output.INFO);
<a name="l00335"></a>00335                                         ignoringThreads[i] = -2;
<a name="l00336"></a>00336                                 }
<a name="l00337"></a>00337                         }
<a name="l00338"></a>00338                 }
<a name="l00339"></a>00339                 
<a name="l00343"></a><a class="code" href="class_dispatcher.html#a5c3e2fcaf3714fda5b05ef1b386d9477">00343</a>                 <span class="keyword">public</span> function IsThreadIgnoring(thread:<span class="keywordtype">int</span>): Boolean
<a name="l00344"></a>00344                 {
<a name="l00345"></a>00345                         <span class="keywordflow">if</span>(thread &lt; 0)
<a name="l00346"></a>00346                         {
<a name="l00347"></a>00347                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.IsThreadIgnoring(): thread = &quot;</span> + thread + <span class="stringliteral">&quot;. It must be positive.\n&quot;</span>, Output.INFO);
<a name="l00348"></a>00348                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00349"></a>00349                         }
<a name="l00350"></a>00350                         
<a name="l00351"></a>00351                         <span class="comment">//поиск указанного потока в потоках, которые уже игнорируются:</span>
<a name="l00352"></a>00352                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; ignoringThreads.length; i++)
<a name="l00353"></a>00353                         {
<a name="l00354"></a>00354                                 <span class="keywordflow">if</span>(ignoringThreads[i] == thread)
<a name="l00355"></a>00355                                 {
<a name="l00356"></a>00356                                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.IsThreadIgnoring(): ignoring thread &quot;</span> + thread + <span class="stringliteral">&quot; found.\n&quot;</span>, Output.INFO);
<a name="l00357"></a>00357                                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00358"></a>00358                                 }
<a name="l00359"></a>00359                         }
<a name="l00360"></a>00360                         
<a name="l00361"></a>00361                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00362"></a>00362                 }
<a name="l00363"></a>00363                 
<a name="l00368"></a><a class="code" href="class_dispatcher.html#a27de11303d77c1d22962eccd6ffec1da">00368</a>                 <span class="keyword">public</span> function IgnoreQueue(queueId:<span class="keywordtype">int</span>): void
<a name="l00369"></a>00369                 {
<a name="l00370"></a>00370                         <span class="comment">//проверку номера очереди на правильность совершать не нужно, из-за использования индексов очередей (например можно сначала указать игнорирование очереди с указанным индексом, а только потом создать очередь с таким индексом):</span>
<a name="l00371"></a>00371                         <span class="keywordflow">if</span>(queueId &lt; -1)
<a name="l00372"></a>00372                         {
<a name="l00373"></a>00373                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.IgnoreQueue(): queueId = &quot;</span> + queueId + <span class="stringliteral">&quot;. It must be positive.\n&quot;</span>, Output.ERROR);
<a name="l00374"></a>00374                                 <span class="keywordflow">return</span>;
<a name="l00375"></a>00375                         }
<a name="l00376"></a>00376                         
<a name="l00377"></a>00377                         ignoringQueues.push(queueId);
<a name="l00378"></a>00378                 }
<a name="l00379"></a>00379                 
<a name="l00384"></a><a class="code" href="class_dispatcher.html#a9a1ea13d0d45be3c7ae805c64e5f7fc9">00384</a>                 <span class="keyword">public</span> function ResetQueueIgnoring(queueId:<span class="keywordtype">int</span>): void
<a name="l00385"></a>00385                 {
<a name="l00386"></a>00386                         <span class="comment">//если указано отменить игнорирование всех очередей:</span>
<a name="l00387"></a>00387                         <span class="keywordflow">if</span>(queueId == -1)
<a name="l00388"></a>00388                         {
<a name="l00389"></a>00389                                 ignoringQueues.length = 0;
<a name="l00390"></a>00390                                 <span class="keywordflow">return</span>;
<a name="l00391"></a>00391                         }
<a name="l00392"></a>00392                         
<a name="l00393"></a>00393                         <span class="keywordflow">if</span>(queueId &lt; -1)
<a name="l00394"></a>00394                         {
<a name="l00395"></a>00395                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.ResetQueueIgnoring(): queueId = &quot;</span> + queueId + <span class="stringliteral">&quot;. It must be positive.\n&quot;</span>, Output.ERROR);
<a name="l00396"></a>00396                                 <span class="keywordflow">return</span>;
<a name="l00397"></a>00397                         }
<a name="l00398"></a>00398                         
<a name="l00399"></a>00399                         <span class="comment">//поиск указанной очереди в списке игнорируемых очередей и замена на такое число, индекса очереди которой точно не будет:</span>
<a name="l00400"></a>00400                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; ignoringQueues.length; i++)
<a name="l00401"></a>00401                         {
<a name="l00402"></a>00402                                 <span class="keywordflow">if</span>(ignoringQueues[i] == queueId)
<a name="l00403"></a>00403                                 {
<a name="l00404"></a>00404                                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.ResetQueueIgnoring(): ignoring queue &quot;</span> + queueId + <span class="stringliteral">&quot; found.\n&quot;</span>, Output.INFO);
<a name="l00405"></a>00405                                         ignoringQueues[i] = -2;
<a name="l00406"></a>00406                                 }
<a name="l00407"></a>00407                         }
<a name="l00408"></a>00408                 }
<a name="l00409"></a>00409                 
<a name="l00411"></a><a class="code" href="class_dispatcher.html#ae31a2cae1291b36c5f98503fe8d10e73">00411</a>                 <span class="keyword">public</span> function IsQueueIgnoring(queueId:<span class="keywordtype">int</span>): Boolean
<a name="l00412"></a>00412                 {
<a name="l00413"></a>00413                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; ignoringQueues.length; i++)
<a name="l00414"></a>00414                         {
<a name="l00415"></a>00415                                 <span class="keywordflow">if</span>(ignoringQueues[i] == queueId) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00416"></a>00416                         }
<a name="l00417"></a>00417                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00418"></a>00418                 }
<a name="l00419"></a>00419                 
<a name="l00424"></a><a class="code" href="class_dispatcher.html#ad4728212c48d5c2947a4fc3ae2fffff3">00424</a>                 <span class="keyword">public</span> function CreateAction(queueId:<span class="keywordtype">int</span>, actionDesc:<a class="code" href="class_action_desc.html" title="Используется для описания действия перед добавлением в очередь.">ActionDesc</a>): <a class="code" href="class_action_creation_result.html" title="В очередь с каким идентификатором было добавлено действие функцией Dispatcher.CreateAction() и под ка...">ActionCreationResult</a>
<a name="l00425"></a>00425                 {
<a name="l00426"></a>00426                         var actionCreationResult:<a class="code" href="class_action_creation_result.html" title="В очередь с каким идентификатором было добавлено действие функцией Dispatcher.CreateAction() и под ка...">ActionCreationResult</a> = <span class="keyword">new</span> <a class="code" href="class_action_creation_result.html" title="В очередь с каким идентификатором было добавлено действие функцией Dispatcher.CreateAction() и под ка...">ActionCreationResult</a>(-1, -1);
<a name="l00427"></a>00427                         
<a name="l00428"></a>00428                         <span class="keywordflow">if</span>(queueId &lt; -1)
<a name="l00429"></a>00429                         {
<a name="l00430"></a>00430                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.CreateAction(): queueId = &quot;</span> + queueId + <span class="stringliteral">&quot;. It must be positive.\n&quot;</span>, Output.ERROR);
<a name="l00431"></a>00431                                 <span class="keywordflow">return</span> actionCreationResult;
<a name="l00432"></a>00432                         }
<a name="l00433"></a>00433                         
<a name="l00434"></a>00434                         queueId = AddAction(queueId, actionDesc);
<a name="l00435"></a>00435                         
<a name="l00436"></a>00436                         <span class="comment">//возвращаем индекс очереди, в которую было добавлено текущее действие и индекс действия в этой очереди:</span>
<a name="l00437"></a>00437                         actionCreationResult.queueId = queueId;
<a name="l00438"></a>00438                         <span class="keyword">const</span> queueIndex:<span class="keywordtype">int</span> = QueueIndexFromId(queueId);
<a name="l00439"></a>00439                         var queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = queues[queueIndex];
<a name="l00440"></a>00440                         actionCreationResult.actionIndex = queue.<a class="code" href="class_queue.html#afc8851fd9af482a9e8b0e0bb09eab3a5" title="Количество действий.">ActionsCount</a>() - 1;
<a name="l00441"></a>00441                         
<a name="l00442"></a>00442                         <span class="keywordflow">return</span> actionCreationResult;
<a name="l00443"></a>00443                 }
<a name="l00444"></a>00444                 
<a name="l00448"></a><a class="code" href="class_dispatcher.html#a357d20dea7bb51004e413c946d74fe08">00448</a>                 <span class="keyword">public</span> function GoToAction(queueId:<span class="keywordtype">int</span>, actionIndex:<span class="keywordtype">int</span>): void
<a name="l00449"></a>00449                 {
<a name="l00450"></a>00450                         var queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = GetQueue(queueId);
<a name="l00451"></a>00451                         <span class="keywordflow">if</span>(queue == null)
<a name="l00452"></a>00452                         {
<a name="l00453"></a>00453                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.GoToAction(): there are no queue with id = &quot;</span> + queueId + <span class="stringliteral">&quot;.\n&quot;</span>, Output.ERROR);
<a name="l00454"></a>00454                                 <span class="keywordflow">return</span>;
<a name="l00455"></a>00455                         }
<a name="l00456"></a>00456                         
<a name="l00457"></a>00457                         queue.GoToAction(actionIndex);
<a name="l00458"></a>00458                 }
<a name="l00459"></a>00459                 
<a name="l00463"></a><a class="code" href="class_dispatcher.html#a7e8589b8500658ddedd569aab14ac5a7">00463</a>                 <span class="keyword">public</span> function ActionsCount(queueId:<span class="keywordtype">int</span>): int
<a name="l00464"></a>00464                 {
<a name="l00465"></a>00465                         var queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = GetQueue(queueId);
<a name="l00466"></a>00466                         <span class="keywordflow">if</span>(queue == null)
<a name="l00467"></a>00467                         {
<a name="l00468"></a>00468                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.ActionsCount(): there are no queue with id = &quot;</span> + queueId + <span class="stringliteral">&quot;.\n&quot;</span>, Output.ERROR);
<a name="l00469"></a>00469                                 <span class="keywordflow">return</span> 0;
<a name="l00470"></a>00470                         }
<a name="l00471"></a>00471                         <span class="keywordflow">return</span> queue.ActionsCount();
<a name="l00472"></a>00472                 }
<a name="l00473"></a>00473                 
<a name="l00481"></a><a class="code" href="class_dispatcher.html#a499b2e8100a800c16abb095c32ef8e16">00481</a>                 <span class="keyword">public</span> function IsActionsEnded(... queues): Boolean
<a name="l00482"></a>00482                 {
<a name="l00483"></a>00483                         <span class="comment">//закончились ли действия:</span>
<a name="l00484"></a>00484                         var isActionsEnded:Boolean = <span class="keyword">true</span>;
<a name="l00485"></a>00485                         
<a name="l00486"></a>00486                         <span class="comment">//если нужно проверять в конкретных очередях:</span>
<a name="l00487"></a>00487                         <span class="keywordflow">if</span>(queues.length &gt; 0)
<a name="l00488"></a>00488                         {
<a name="l00489"></a>00489                                 <span class="keywordflow">for each</span>(var queueId:<span class="keywordtype">int</span> <span class="keywordflow">in</span> queues)
<a name="l00490"></a>00490                                 {
<a name="l00491"></a>00491                                         var queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = GetQueue(queueId);
<a name="l00492"></a>00492                                         <span class="comment">//если очередь с таким идентификатором вообще существует:</span>
<a name="l00493"></a>00493                                         <span class="keywordflow">if</span>(queue != null)
<a name="l00494"></a>00494                                         {
<a name="l00495"></a>00495                                                 <span class="keywordflow">if</span>(queue.CurrentAction() != null)
<a name="l00496"></a>00496                                                 {
<a name="l00497"></a>00497                                                         isActionsEnded = <span class="keyword">false</span>;
<a name="l00498"></a>00498                                                         <span class="keywordflow">break</span>;
<a name="l00499"></a>00499                                                 }
<a name="l00500"></a>00500                                         }
<a name="l00501"></a>00501                                         <span class="keywordflow">else</span>
<a name="l00502"></a>00502                                         {
<a name="l00503"></a>00503                                                 output.Out(<span class="stringliteral">&quot;W: Dispatcher.IsActionsEnded(): queue with id = &quot;</span> + queueId + <span class="stringliteral">&quot; does NOT exist.\n&quot;</span>, Output.WARN);
<a name="l00504"></a>00504                                         }
<a name="l00505"></a>00505                                 }
<a name="l00506"></a>00506                         }
<a name="l00507"></a>00507                         <span class="comment">//если нужно проверять все очереди:</span>
<a name="l00508"></a>00508                         <span class="keywordflow">else</span>
<a name="l00509"></a>00509                         {
<a name="l00510"></a>00510                                 <span class="keywordflow">for</span>(var queueIndex:<span class="keywordtype">int</span> = 0; queueIndex &lt; this.queues.length; queueIndex++)
<a name="l00511"></a>00511                                 {
<a name="l00512"></a>00512                                         <span class="keywordflow">if</span>(this.queues[queueIndex].CurrentAction() != null)
<a name="l00513"></a>00513                                         {
<a name="l00514"></a>00514                                                 isActionsEnded = <span class="keyword">false</span>;
<a name="l00515"></a>00515                                                 <span class="keywordflow">break</span>;
<a name="l00516"></a>00516                                         }
<a name="l00517"></a>00517                                 }
<a name="l00518"></a>00518                         }
<a name="l00519"></a>00519                         
<a name="l00520"></a>00520                         <span class="keywordflow">return</span> isActionsEnded;
<a name="l00521"></a>00521                 }
<a name="l00522"></a>00522                 
<a name="l00523"></a>00523                 
<a name="l00524"></a>00524                 
<a name="l00529"></a><a class="code" href="class_dispatcher.html#a42ecf8368c5294adca29288ce94abbd8">00529</a>                 <span class="keyword">private</span> function GetQueue(<span class="keywordtype">id</span>:<span class="keywordtype">int</span>): <a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a>
<a name="l00530"></a>00530                 {
<a name="l00531"></a>00531                         <span class="keyword">const</span> index:<span class="keywordtype">int</span> = QueueIndexFromId(<span class="keywordtype">id</span>);
<a name="l00532"></a>00532                         
<a name="l00533"></a>00533                         <span class="comment">//если очереди с указанным id не существует:</span>
<a name="l00534"></a>00534                         <span class="keywordflow">if</span>(index == -1) <span class="keywordflow">return</span> null;
<a name="l00535"></a>00535                         <span class="keywordflow">return</span> queues[index];
<a name="l00536"></a>00536                 }
<a name="l00537"></a>00537                 
<a name="l00542"></a><a class="code" href="class_dispatcher.html#acf72c84e3b1e64b3f745360156727dc0">00542</a>                 <span class="keyword">private</span> function QueueIndexFromId(<span class="keywordtype">id</span>:<span class="keywordtype">int</span>, silent:Boolean = <span class="keyword">false</span>): int
<a name="l00543"></a>00543                 {
<a name="l00544"></a>00544                         <span class="keywordflow">if</span> (silent == <span class="keyword">false</span>) output.Out(<span class="stringliteral">&quot;I: Dispatcher.QueueIndexFromId()\n&quot;</span>, Output.INFO);
<a name="l00545"></a>00545                         var foundIndex:<span class="keywordtype">int</span> = -1;
<a name="l00546"></a>00546                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; redirections.length; i++)
<a name="l00547"></a>00547                         {
<a name="l00548"></a>00548                                 <span class="keywordflow">if</span>(redirections[i].<span class="keywordtype">id</span> == <span class="keywordtype">id</span>)
<a name="l00549"></a>00549                                 {
<a name="l00550"></a>00550                                         foundIndex = redirections[i].index;
<a name="l00551"></a>00551                                         <span class="keywordflow">break</span>;
<a name="l00552"></a>00552                                 }
<a name="l00553"></a>00553                         }
<a name="l00554"></a>00554                         <span class="keywordflow">if</span>(foundIndex == -1)
<a name="l00555"></a>00555                         {
<a name="l00556"></a>00556                                 <span class="keywordflow">if</span>(silent == <span class="keyword">false</span>) output.Out(<span class="stringliteral">&quot;I: Dispatcher.QueueIndexFromId(): there are NO queue with id = &quot;</span> + <span class="keywordtype">id</span> + <span class="stringliteral">&quot;. Not so bad - it can be just looking for queue with such id in case of first deal adding.\n&quot;</span>, Output.INFO);
<a name="l00557"></a>00557                         }
<a name="l00558"></a>00558                         <span class="keywordflow">else</span> output.Out(<span class="stringliteral">&quot;I: Dispatcher.QueueIndexFromId(): queue with id = &quot;</span> + <span class="keywordtype">id</span> + <span class="stringliteral">&quot; found. It has index = &quot;</span> + foundIndex + <span class="stringliteral">&quot;.\n&quot;</span>, Output.INFO);
<a name="l00559"></a>00559                         
<a name="l00560"></a>00560                         <span class="keywordflow">return</span> foundIndex;
<a name="l00561"></a>00561                 }
<a name="l00562"></a>00562                 
<a name="l00566"></a><a class="code" href="class_dispatcher.html#a7033253e70a97f1ed7835d06edb61645">00566</a>                 <span class="keyword">private</span> function QueueIdFromIndex(index:<span class="keywordtype">int</span>): int
<a name="l00567"></a>00567                 {
<a name="l00568"></a>00568                         <span class="keywordflow">if</span>(index &lt; 0 || index &gt;= queues.length)
<a name="l00569"></a>00569                         {
<a name="l00570"></a>00570                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.QueueIdFromIndex(): index = &quot;</span> + index + <span class="stringliteral">&quot; is wrong. Returning -1.\n&quot;</span>, Output.INFO);
<a name="l00571"></a>00571                                 <span class="keywordflow">return</span> -1;
<a name="l00572"></a>00572                         }
<a name="l00573"></a>00573                         
<a name="l00574"></a>00574                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; redirections.length; i++)
<a name="l00575"></a>00575                         {
<a name="l00576"></a>00576                                 <span class="keywordflow">if</span>(redirections[i].index == index) <span class="keywordflow">return</span> redirections[i].id;
<a name="l00577"></a>00577                         }
<a name="l00578"></a>00578                         <span class="keywordflow">return</span> -1;
<a name="l00579"></a>00579                 }
<a name="l00580"></a>00580                 
<a name="l00586"></a><a class="code" href="class_dispatcher.html#a217c0c17300ffc34e132e9a7aeb79940">00586</a>                 <span class="keyword">private</span> function AppendRedirection(<span class="keywordtype">id</span>:<span class="keywordtype">int</span>, queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a>): int
<a name="l00587"></a>00587                 {
<a name="l00588"></a>00588                         <span class="comment">//если было указано добавить очередь с любым свободным идентификатором:</span>
<a name="l00589"></a>00589                         <span class="keywordflow">if</span>(<span class="keywordtype">id</span> == -1)
<a name="l00590"></a>00590                         {
<a name="l00591"></a>00591                                 <span class="keywordtype">id</span> = GetFreeId();
<a name="l00592"></a>00592                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.AppendRedirection(): id was equal -1. So found free id = &quot;</span> + <span class="keywordtype">id</span> + <span class="stringliteral">&quot;.\n&quot;</span>, Output.INFO);
<a name="l00593"></a>00593                         }
<a name="l00594"></a>00594                         
<a name="l00595"></a>00595                         <span class="comment">//удостовериться, что очереди с указанным идентификатором ещё не существует:</span>
<a name="l00596"></a>00596                         var existingIndex:<span class="keywordtype">int</span> = QueueIndexFromId(<span class="keywordtype">id</span>, <span class="keyword">true</span>);
<a name="l00597"></a>00597                         <span class="comment">//если очередь с таким идентификатором уже существует:</span>
<a name="l00598"></a>00598                         <span class="keywordflow">if</span>(existingIndex != -1)
<a name="l00599"></a>00599                         {
<a name="l00600"></a>00600                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.AppendRedirection(): queue with id = &quot;</span> + <span class="keywordtype">id</span> + <span class="stringliteral">&quot; already exists.\n&quot;</span>, Output.ERROR);
<a name="l00601"></a>00601                                 <span class="keywordflow">return</span> -1;
<a name="l00602"></a>00602                         }
<a name="l00603"></a>00603                         
<a name="l00604"></a>00604                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.AppendRedirection(): queue with id = &quot;</span> + <span class="keywordtype">id</span> + <span class="stringliteral">&quot; has index = &quot;</span> + existingIndex + <span class="stringliteral">&quot;.\n&quot;</span>, Output.INFO);
<a name="l00605"></a>00605                         
<a name="l00606"></a>00606                         <span class="comment">//добавление нового перенаправления:</span>
<a name="l00607"></a>00607                         var idToIndex:<a class="code" href="class_id_to_index.html" title="Перенаправление идентификатора очереди на индекс в массиве очередей.">IdToIndex</a> = <span class="keyword">new</span> <a class="code" href="class_id_to_index.html" title="Перенаправление идентификатора очереди на индекс в массиве очередей.">IdToIndex</a>(<span class="keywordtype">id</span>, redirections.length);
<a name="l00608"></a>00608                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.AppendRedirection(): created new IdToIndex =\n                idToIndex.id = &quot;</span> + idToIndex.id + <span class="stringliteral">&quot;;\n          idToIndex.index = &quot;</span> + idToIndex.index + <span class="stringliteral">&quot;;\n&quot;</span>, Output.INFO);
<a name="l00609"></a>00609                         redirections.push(idToIndex);
<a name="l00610"></a>00610                         <span class="comment">//добавление очереди:</span>
<a name="l00611"></a>00611                         queues.push(queue);
<a name="l00612"></a>00612                         <span class="comment">//новая сортировка идентификаторов по возрастанию:</span>
<a name="l00613"></a>00613                         ResortRedirections();
<a name="l00614"></a>00614                         
<a name="l00615"></a>00615                         <span class="comment">//возвращаем идентификатор только что добавленной очереди:</span>
<a name="l00616"></a>00616                         <span class="keywordflow">return</span> id;
<a name="l00617"></a>00617                 }
<a name="l00618"></a>00618                 
<a name="l00620"></a><a class="code" href="class_dispatcher.html#a323f886e653885b568cd2dcfabe505b1">00620</a>                 <span class="keyword">private</span> function ResortRedirections(): void
<a name="l00621"></a>00621                 {
<a name="l00622"></a>00622                         <span class="keywordflow">if</span>(redirections.length == 0)
<a name="l00623"></a>00623                         {
<a name="l00624"></a>00624                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.ResortRedirection(): there are NO redirection elements.\n&quot;</span>, Output.INFO);
<a name="l00625"></a>00625                                 <span class="keywordflow">return</span>;
<a name="l00626"></a>00626                         }
<a name="l00627"></a>00627                         
<a name="l00628"></a>00628                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.ResortRedirection(): array before resorting:\n&quot;</span>, Output.INFO);
<a name="l00629"></a>00629                         <span class="keywordflow">for</span>(var printingBefore:<span class="keywordtype">int</span> = 0; printingBefore &lt; redirections.length; printingBefore++)
<a name="l00630"></a>00630                         {
<a name="l00631"></a>00631                                 output.Out(<span class="stringliteral">&quot;    | &quot;</span> + redirections[printingBefore].<span class="keywordtype">id</span> + <span class="stringliteral">&quot; | &quot;</span> + redirections[printingBefore].index + <span class="stringliteral">&quot; |\n&quot;</span>, Output.INFO);
<a name="l00632"></a>00632                         }
<a name="l00633"></a>00633                         
<a name="l00634"></a>00634                         <span class="comment">//каждое перенаправление (IdToIndex) будет копироваться из redirections в resorted, начиная с наименьших id:</span>
<a name="l00635"></a>00635                         var resorted:Array = [];
<a name="l00636"></a>00636                         
<a name="l00637"></a>00637                         var minId:<span class="keywordtype">int</span> = -1;
<a name="l00638"></a>00638                         var indexOfMinId:<span class="keywordtype">int</span> = 0;
<a name="l00639"></a>00639                         <span class="comment">//копирование каждого перенаправления:</span>
<a name="l00640"></a>00640                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; redirections.length; i++)
<a name="l00641"></a>00641                         {
<a name="l00642"></a>00642                                 <span class="comment">//поиск минимального перенаправления:</span>
<a name="l00643"></a>00643                                 <span class="keywordflow">for</span>(var i2:<span class="keywordtype">int</span> = 0; i2 &lt; redirections.length; i2++)
<a name="l00644"></a>00644                                 {
<a name="l00645"></a>00645                                         <span class="comment">//если id == -1, то он уже скопирован:</span>
<a name="l00646"></a>00646                                         <span class="keywordflow">if</span>(redirections[i2].<span class="keywordtype">id</span> == -1) <span class="keywordflow">continue</span>;
<a name="l00647"></a>00647                                         
<a name="l00648"></a>00648                                         <span class="comment">//если minId == -1, то ещё ни один минимальный id не был найден:</span>
<a name="l00649"></a>00649                                         <span class="keywordflow">if</span>(minId == -1)
<a name="l00650"></a>00650                                         {
<a name="l00651"></a>00651                                                 minId = redirections[i2].id;
<a name="l00652"></a>00652                                                 indexOfMinId = i2;
<a name="l00653"></a>00653                                                 <span class="keywordflow">continue</span>;
<a name="l00654"></a>00654                                         }
<a name="l00655"></a>00655                                         <span class="keywordflow">else</span>
<a name="l00656"></a>00656                                         {
<a name="l00657"></a>00657                                                 <span class="keywordflow">if</span>(redirections[i2].<span class="keywordtype">id</span> &lt; minId)
<a name="l00658"></a>00658                                                 {
<a name="l00659"></a>00659                                                         minId = redirections[i2].id;
<a name="l00660"></a>00660                                                         indexOfMinId = i2;
<a name="l00661"></a>00661                                                         <span class="keywordflow">continue</span>;
<a name="l00662"></a>00662                                                 }
<a name="l00663"></a>00663                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(redirections[i2].<span class="keywordtype">id</span> == minId)
<a name="l00664"></a>00664                                                 {
<a name="l00665"></a>00665                                                         output.Out(<span class="stringliteral">&quot;E: Dispatcher.ResortRedirection(): found redirections with similiar id:\n   redirections[&quot;</span> + indexOfMinId + <span class="stringliteral">&quot;].id = &quot;</span> + redirections[indexOfMinId].<span class="keywordtype">id</span> + <span class="stringliteral">&quot;;\n        redirections[&quot;</span> + indexOfMinId + <span class="stringliteral">&quot;].index = &quot;</span> + redirections[indexOfMinId].index + <span class="stringliteral">&quot;;\n  redirections[&quot;</span> + i2 + <span class="stringliteral">&quot;].id = &quot;</span> + redirections[i2].<span class="keywordtype">id</span> + <span class="stringliteral">&quot;;\n    redirections[&quot;</span> + i2 + <span class="stringliteral">&quot;].index = &quot;</span> + redirections[i2].index + <span class="stringliteral">&quot;;\n&quot;</span>, Output.ERROR);
<a name="l00666"></a>00666                                                 }
<a name="l00667"></a>00667                                         }
<a name="l00668"></a>00668                                 }
<a name="l00669"></a>00669                                 
<a name="l00670"></a>00670                                 <span class="comment">//копирование перенаправления с минимально найденным индексом:</span>
<a name="l00671"></a>00671                                 var copying:<a class="code" href="class_id_to_index.html" title="Перенаправление идентификатора очереди на индекс в массиве очередей.">IdToIndex</a> = redirections[indexOfMinId];
<a name="l00672"></a>00672                                 var dest:<a class="code" href="class_id_to_index.html" title="Перенаправление идентификатора очереди на индекс в массиве очередей.">IdToIndex</a> = <span class="keyword">new</span> <a class="code" href="class_id_to_index.html" title="Перенаправление идентификатора очереди на индекс в массиве очередей.">IdToIndex</a>(copying.id, copying.index);
<a name="l00673"></a>00673                                 resorted[i] = dest;
<a name="l00674"></a>00674                                 <span class="comment">//указываем, что это перенаправление уже скопировано:</span>
<a name="l00675"></a>00675                                 redirections[indexOfMinId].id = -1;
<a name="l00676"></a>00676                                 
<a name="l00677"></a>00677                                 minId = -1;
<a name="l00678"></a>00678                                 indexOfMinId = 0;
<a name="l00679"></a>00679                         }
<a name="l00680"></a>00680                         
<a name="l00681"></a>00681                         redirections = resorted;
<a name="l00682"></a>00682                         
<a name="l00683"></a>00683                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.ResortRedirection(): array AFTER resorting:\n&quot;</span>, Output.INFO);
<a name="l00684"></a>00684                         <span class="keywordflow">for</span>(var printingAfter:<span class="keywordtype">int</span> = 0; printingAfter &lt; redirections.length; printingAfter++)
<a name="l00685"></a>00685                         {
<a name="l00686"></a>00686                                 output.Out(<span class="stringliteral">&quot;    | &quot;</span> + redirections[printingAfter].<span class="keywordtype">id</span> + <span class="stringliteral">&quot; | &quot;</span> + redirections[printingAfter].index + <span class="stringliteral">&quot; |\n&quot;</span>, Output.INFO);
<a name="l00687"></a>00687                         }
<a name="l00688"></a>00688                 }
<a name="l00689"></a>00689                 
<a name="l00691"></a><a class="code" href="class_dispatcher.html#aad8e46b2fba81e3fd98fb5a182d113c1">00691</a>                 <span class="keyword">private</span> function GetFreeId(): int
<a name="l00692"></a>00692                 {
<a name="l00693"></a>00693                         <span class="comment">//ещё не занятый идентификатор:</span>
<a name="l00694"></a>00694                         var freeId:<span class="keywordtype">int</span> = 0;
<a name="l00695"></a>00695                         <span class="comment">//найдена ли очередь с таким идентификатором (есть ли пересечение):</span>
<a name="l00696"></a>00696                         var suchIdExists:Boolean = <span class="keyword">false</span>;
<a name="l00697"></a>00697                         <span class="comment">//поиск свободного идентификатора:</span>
<a name="l00698"></a>00698                         <span class="keywordflow">for</span>(var i:<span class="keywordtype">int</span> = 0; i &lt; redirections.length; i++)
<a name="l00699"></a>00699                         {
<a name="l00700"></a>00700                                 <span class="keywordflow">for</span>(var i2:<span class="keywordtype">int</span> = 0; i2 &lt; redirections.length; i2++)
<a name="l00701"></a>00701                                 {
<a name="l00702"></a>00702                                         <span class="keywordflow">if</span>(freeId == redirections[i2].<span class="keywordtype">id</span>)
<a name="l00703"></a>00703                                         {
<a name="l00704"></a>00704                                                 suchIdExists = <span class="keyword">true</span>;
<a name="l00705"></a>00705                                                 <span class="keywordflow">break</span>;
<a name="l00706"></a>00706                                         }
<a name="l00707"></a>00707                                 }
<a name="l00708"></a>00708                                 
<a name="l00709"></a>00709                                 <span class="keywordflow">if</span>(suchIdExists == <span class="keyword">true</span>)
<a name="l00710"></a>00710                                 {
<a name="l00711"></a>00711                                         freeId++;
<a name="l00712"></a>00712                                         suchIdExists = <span class="keyword">false</span>;
<a name="l00713"></a>00713                                         <span class="keywordflow">continue</span>;
<a name="l00714"></a>00714                                 }
<a name="l00715"></a>00715                                 <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l00716"></a>00716                         }
<a name="l00717"></a>00717                         
<a name="l00718"></a>00718                         output.Out(<span class="stringliteral">&quot;I: Dispatcher.GetFreeId(): free id = &quot;</span> + freeId + <span class="stringliteral">&quot; found.\n&quot;</span>, Output.INFO);
<a name="l00719"></a>00719                         <span class="keywordflow">return</span> freeId;
<a name="l00720"></a>00720                 }
<a name="l00721"></a>00721                 
<a name="l00728"></a><a class="code" href="class_dispatcher.html#ae9369329c2a8e0add43949072f804918">00728</a>                 <span class="keyword">private</span> function AddAction(queueId:<span class="keywordtype">int</span>, actionDesc:<a class="code" href="class_action_desc.html" title="Используется для описания действия перед добавлением в очередь.">ActionDesc</a>): int
<a name="l00729"></a>00729                 {
<a name="l00730"></a>00730                         <span class="keywordflow">if</span>(queueId &lt; -1)
<a name="l00731"></a>00731                         {
<a name="l00732"></a>00732                                 output.Out(<span class="stringliteral">&quot;E: Dispatcher.AddAction(): queueId = &quot;</span> + queueId + <span class="stringliteral">&quot;. It must be positive.\n&quot;</span>, Output.ERROR);
<a name="l00733"></a>00733                                 <span class="keywordflow">return</span> -1;
<a name="l00734"></a>00734                         }
<a name="l00735"></a>00735                         
<a name="l00736"></a>00736                         var action:<a class="code" href="class_action.html" title="Абстрактный класс действия внутри очереди.">Action</a> = actionDesc.CreateAction();
<a name="l00737"></a>00737                         
<a name="l00738"></a>00738                         <span class="comment">//queueIndex будет = -1 либо если queueId указано -1 (изначально), либо если такой очереди ещё не существует:</span>
<a name="l00739"></a>00739                         var queueIndex:<span class="keywordtype">int</span> = QueueIndexFromId(queueId);
<a name="l00740"></a>00740                         <span class="comment">//создаём и добавляем новую очередь:</span>
<a name="l00741"></a>00741                         <span class="keywordflow">if</span>(queueIndex == -1)
<a name="l00742"></a>00742                         {
<a name="l00743"></a>00743                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.AddAction(): there are NO queue with id = &quot;</span> + queueId + <span class="stringliteral">&quot;. Will be created new queue.\n&quot;</span>, Output.INFO);
<a name="l00744"></a>00744                                 var queue:<a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a> = <span class="keyword">new</span> <a class="code" href="class_queue.html" title="Очередь выполняемых действий.">Queue</a>(output);
<a name="l00745"></a>00745                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.AddAction(): queue created.\n&quot;</span>, Output.INFO);
<a name="l00746"></a>00746                                 queue.AddAction(action);
<a name="l00747"></a>00747                                 output.Out(<span class="stringliteral">&quot;I: Dispatcher.AddAction(): appending redirection.\n&quot;</span>, Output.INFO);
<a name="l00748"></a>00748                                 queueId = AppendRedirection(queueId, queue);
<a name="l00749"></a>00749                                 <span class="keywordflow">if</span>(queueId == -1)
<a name="l00750"></a>00750                                 {
<a name="l00751"></a>00751                                         output.Out(<span class="stringliteral">&quot;E: Dispatcher.AddAction(): queue was NOT appended. Trying id = &quot;</span> + queueId + <span class="stringliteral">&quot;.\n&quot;</span>, Output.ERROR);
<a name="l00752"></a>00752                                         <span class="comment">//в этом языке не нужно удалять очередь после её неудачного добавления...</span>
<a name="l00753"></a>00753                                 }
<a name="l00754"></a>00754                         }
<a name="l00755"></a>00755                         <span class="comment">//в противном случае добавляем действие в уже существующую очередь:</span>
<a name="l00756"></a>00756                         <span class="keywordflow">else</span>
<a name="l00757"></a>00757                         {
<a name="l00758"></a>00758                                 queues[queueIndex].AddAction(action);
<a name="l00759"></a>00759                         }
<a name="l00760"></a>00760                         
<a name="l00761"></a>00761                         <span class="comment">//возвращаем индекс очереди, в которую было добавлено текущее действие:</span>
<a name="l00762"></a>00762                         <span class="keywordflow">return</span> queueId;
<a name="l00763"></a>00763                 }
<a name="l00764"></a>00764                 
<a name="l00767"></a><a class="code" href="class_dispatcher.html#a4f7449245ac186e3798c104cbfee98f4">00767</a>                 <span class="keyword">public</span> <span class="keyword">static</span> function CheckArguments(context:String, param:<a class="code" href="class_param.html">Param</a>, count:<span class="keywordtype">int</span>): Boolean
<a name="l00768"></a>00768                 {
<a name="l00769"></a>00769                         <span class="keywordflow">for</span> (var i:<span class="keywordtype">int</span> = 0; i &lt; count; i++)
<a name="l00770"></a>00770                         {
<a name="l00771"></a>00771                                 <span class="keywordflow">if</span> (param.argumentsAsActions[i] == undefined)
<a name="l00772"></a>00772                                 {
<a name="l00773"></a>00773                                         param.action.output.Out(<span class="stringliteral">&quot;E: CheckArguments(): &quot;</span> + context + <span class="stringliteral">&quot;: no argument at index &quot;</span> + i + <span class="stringliteral">&quot; (zero-based).&quot;</span>, Output.ERROR);
<a name="l00774"></a>00774                                         param.queue.ActionEnded();
<a name="l00775"></a>00775                                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00776"></a>00776                                 }
<a name="l00777"></a>00777                         }
<a name="l00778"></a>00778                         
<a name="l00779"></a>00779                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00780"></a>00780                 }
<a name="l00781"></a>00781                 
<a name="l00783"></a><a class="code" href="class_dispatcher.html#ab710f406ff0726bf12850d3bca0ff1c2">00783</a>                 <span class="keyword">public</span> <span class="keyword">static</span> function InitData(param:<a class="code" href="class_param.html">Param</a>, count:<span class="keywordtype">int</span>): void
<a name="l00784"></a>00784                 {
<a name="l00785"></a>00785                         <span class="keywordflow">for</span> (var i:<span class="keywordtype">int</span> = 0; i &lt; count; i++)
<a name="l00786"></a>00786                         {
<a name="l00787"></a>00787                                 param.action.data[i] = <span class="keyword">new</span> <a class="code" href="class_abstract_data.html" title="Абстрактный тип переменной. Для возможности передачи параметров любого типа в ActionDesc ...">AbstractData</a>;
<a name="l00788"></a>00788                         }
<a name="l00789"></a>00789                 }
<a name="l00790"></a>00790                 
<a name="l00793"></a><a class="code" href="class_dispatcher.html#a6024d983f407d27a44f9aadaee1ab6e9">00793</a>                 <span class="keyword">public</span> <span class="keyword">static</span> function CastTo(context:String, param:<a class="code" href="class_param.html">Param</a>, which:<span class="keywordtype">int</span>, type:Class): Boolean
<a name="l00794"></a>00794                 {
<a name="l00795"></a>00795                         var some:* = param.argumentsAsActions[which].GetData().GetData();
<a name="l00796"></a>00796                         <span class="keywordflow">if</span> ((some is type) == <span class="keyword">false</span>)
<a name="l00797"></a>00797                         {
<a name="l00798"></a>00798                                 param.action.output.Out(<span class="stringliteral">&quot;E: CastTo(): &quot;</span> + context + <span class="stringliteral">&quot;: &quot;</span> + some + <span class="stringliteral">&quot; is NOT of type &quot;</span> + type + <span class="stringliteral">&quot;.&quot;</span>, Output.INFO);
<a name="l00799"></a>00799                                 param.queue.ActionEnded();
<a name="l00800"></a>00800                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00801"></a>00801                         }
<a name="l00802"></a>00802                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00803"></a>00803                 }
<a name="l00804"></a>00804                 
<a name="l00805"></a>00805         }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Указатель</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Классы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Файлы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Функции</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Переменные</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Документация по "Actions". Последние изменения: Thu Sep 29 2011 18:32:00. Создано системой&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
