/// @condpackage iso.orient{		/// @endcond		/** Тайл, имеющий направления соединений с соседними тайлами (примыкающая дорога, перекрёсток; береговая линия, вода...).*/	public class Combination	{		public var _directions : Vector.< int >;						public function Combination( directions : Vector.< int > )		{			_directions = directions;		}						/** Возвращает true если указанные массивы направлений содержат одинаковые направления (константы из Orientation) вне зависимости от порядка. Подразумевается что ни в одном из массивов нет повторных элементов.*/		public static function IsEqual( firstDirections : Vector.< int >, secondDirections : Vector.< int > ) : Boolean		{			//как минимум количество направлений должно совпадать:			if ( firstDirections.length != secondDirections.length )			{				return false;			}						var wasAbsence : Boolean = false;						//каждое заданное направление должно присутствовать в другом массиве:			for each ( var neededDirection : int in firstDirections )			{				var wasNeededDirectionFound : Boolean = false;				for each ( var actualDirection : int in secondDirections )				{					//одно из направлений совпало:					if ( neededDirection == actualDirection )					{						wasNeededDirectionFound = true;						break;					}				}				//чтобы по-быстрее прервать бессмысленный цикл:				if ( wasNeededDirectionFound == false )				{					wasAbsence = true;					break;				}			}						if ( wasAbsence )			{				return false;			}						//в directions могут быть повторяющиеся направления и, таким образом, в совокупности эти направления могут уже не совпадать, но это уже дизайнерская ошибка, из ряда вон выходящая...						//если добрались до сюда, то указанные массивы совпадают:			return true;		}				/** Найти комбинацию, в которой имеется именно указанное количество направлений.*/		public static function FindByCount( count : int, where : Vector.< Combination > ) : Combination		{			for each ( var combination : Combination in where )			{				if ( combination._directions.length == count )				{					return combination;				}			}						return null;		}	}}